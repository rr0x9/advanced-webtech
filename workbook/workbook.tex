\UseRawInputEncoding
\documentclass[12pt, a4paper, oneside]{book}

\usepackage{helvet}
\usepackage{hyperref}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{textcomp}
\usepackage[
	a4paper,
	outer=2.5cm,
	inner=2.5cm,
	top=2.5cm,
	bottom=2.5cm
]{geometry}
\usepackage{float}
\usepackage{tabularx}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{framed}
\usepackage{subcaption}
\usepackage{url}

\definecolor{grey}{rgb}{0.9, 0.9, 0.9}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{dkred}{rgb}{0.6,0,0.0}

\lstdefinestyle{CODE}
{
    backgroundcolor=\color{white},
    basicstyle=\small\color{black}\ttfamily,
    stringstyle=\color{black},
    keywords={}z,
    numbers=none
}

\lstdefinestyle{DOS}
{
    backgroundcolor=\color{black},
    basicstyle=\small\color{white}\ttfamily,
    stringstyle=\color{white},
    keywords={}z
}

\lstdefinestyle{makefile}
{
    numberblanklines=false,
    language=make,
    tabsize=4,
    keywordstyle=\color{red},
    identifierstyle= %plain identifiers for make
}

\lstset{
  language=Python,                % the language of the code
  escapeinside={\%*}{*)},
  basicstyle=\footnotesize\ttfamily,
  numbers=left,                   % where to put the line-numbers
  stepnumber=1,                   % the step between two line-numbers. If it's 1, each line
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{dkgreen},       % comment style
  stringstyle=\color{dkred},         % string literal style
  columns=fixed,
  extendedchars=true,
  frame=single,
}

\begin{document}
\clearpage
\newcommand\nbvspace[1][3]{\vspace*{\stretch{#1}}}
\newcommand\nbstretchyspace{\spaceskip0.5em plus 0.25em minus 0.25em}
\newcommand{\nbtitlestretch}{\spaceskip0.6em}
\pagestyle{empty}
\begin{center}
\bfseries
\nbvspace[1]
\Huge
{\nbtitlestretch\huge
Web Technologies: Server-Side}

\nbvspace[1]
\normalsize

COVERING DIVERSE TOPICS RELATED TO \\
DYNAMIC SERVER SIDE WEB AND SERVICE \\ 
DEVELOPMENT WITH ATTENTION PAID TO \\
THE FUTURE OF THE WEB

\nbvspace[1]
\small BY\\
\Large DR SIMON WELLS\\[0.5em]
%\footnotesize AUTHOR OF ``A WORKING ALGEBRA,'' ``WIRELESS TELEGRAPHY,\\
%ITS HISTORY, THEORY AND PRACTICE,'' ETC., ETC.

\nbvspace[2]

\includegraphics[width=2.5in]{images/cover}
\nbvspace[3]
\normalsize

%SCOTLAND\\
\large
SESQUIPEDALIA VERBA PUBLISHING LTD
\nbvspace[1]
\end{center}

\setcounter{tocdepth}{2}
\cleardoublepage
\tableofcontents
\listoffigures
%\listofalgorithms
\addtocontents{toc}{~\hfill\textbf{Page}\par}

\mainmatter


%%%%%%%%%%%%%
%%%%%%%%%%%%%
%%%%%%%%%%%%%       ADMIN
%%%%%%%%%%%%%
%%%%%%%%%%%%%



\part{Admin}

\chapter{Introduction}
\label{intro}

\paragraph{} Welcome to the Advanced Web Technologies module from Edinburgh Napier University. This module has a slightly different structure to many modules so it's worth reading through this guidance before you get stuck into the good stuff.

\paragraph{}This module is about the Web, what the Web is, what we can currently do with the Web, and what the Web might be like in the future. Rather than focus on the user side of web technology, such as CSS and Javascript, which we've all probably seen in other modules (particularly \emph{web tech}, the pre-requisite for this module), we are going to take a more holistic approach and examine both the server and the client side. We shall look at HTTP (the core of all web technologies) and learn how APIs, Web Services, \& RESTful architectures are built to move data around. We will then delve into some more topical discussions, starting with security \& privacy on the web, then looking at adding intelligence (Semantic Web), adding increased, scalable interaction (Realtime Web) and private, anonymous, and un-censorable web-technologies (Dark Web). We wrap up the module by examining a few technologies that might form the basis of future web capabilities like Blockchain and IPFS. Throughout the module you should be using the topics as a starting point. A starting point for your own, self-directed, exploration of the topic in more depth. Because we can only really survey any given aspect during contact time; the real knowledge comes from you digging into it in depth. Also a starting point for you to critically reflect on your own experiences and responses to the topics and issues that we raise in class. Whilst the Web itself is a technical mechanism, a tool for moving data around, it also operates in a very complex socio-technical context that currently affects, and will likely affect to an even larger degree in the future, all our lives.

\paragraph{} Lectures and labs will not necessarily align neatly, the labs will progress, on a week-by-week and chapter-by-chapter basis to form a first course in ``\emph{developing server side web-apps using Python and associated professional practises in a Linux-based environment}''. The lectures will summarise some of this material, providing an opportunity to talk over what we learned in the lab, but primarily, the lectures are an opportunity for us to discuss many other aspects of the Web, focussing in particular on two aspects. Firstly, the structure of the existing Web. Secondly the various facets of Web technologies that influence or alter the way that we use, manipulate, navigate, and share information. These break down into a series of named facets: the semantic web, the realtime web, the dark web, and the permanent web, each of which imposes its own constraints on and proffers opportunities for what the Web is and can do. By looking at each of these in turn we should gain some insight into how the Web is developing, the directions it might take in the future, and perhaps, suggest areas that we can usefully and positively affect.

\chapter{Overview}
\label{overview}
\paragraph{} How should we use this workbook? Ideally we would work through it on a chapter-by-chapter basis supplementing our work with background reading and wider exploration of each topic introducted. Some chapters will take longer to complete than others, and other chapters will need to be returned to multiple times. This is particularly true for the first two chapters. To learn both Linux and Python in a fortnight is a tall order so I'd suggest working iteratively, do enough to make some progress, then frequently return to the respective chapters to learn a little more, usually by following the links and footnotes to further practise materials.

\paragraph{} In the first week work through the first chapter in the lab section of the workbook. You can read ahead if you want but don't try to run any Flask web-apps on the dev server until you've been assigned your personal virtual server to run your own web-apps on. This week is mostly concerned with the foundation of our learning environment. Logging in, learning to navigate and do simple tasks at the command line, using a non-gui text editor, and using Git. There are links, usually in footnotes, throughout the chapter, for example, to practise the Linux command line then there are online web sites like the \emph{LinuxZoo}\footnote{\url{http://www.linuxzoo.net}} that you can use to practise your skills. Similarly, the links to Vim practise tutorials, particularly the Vim game, will help you practise the skills you need to work efficiently in subsequent weeks. Finally, make sure to work through the linked Git tutorials and ensure that you are confident that you understand each of these tools and their place within the learning environment before moving on to subsequent chapters. 

\paragraph{} Each chapter is meant to cover about an entire week of study, so don't rush through things within the scheduled lab session just to tell yourself the you've done all the work. As I mentioned in the introduction, topics, whether in lectures or labs are meant to be a starting place, a framework to guide your self-directed study, but not the totality of your learning. 

\paragraph{} In subsequent weeks you will start to build knowledge of the Python language and the Flask library which provides functionality for building server-hosted web-apps. The next chapter, on Python, is meant to cover at least a weeks work and deliberate practise. Mostly that week is concerned with developing basic skills in a new language, Python, which is actually quite a challenge. This is not because Python is particularly difficult but because learning a computer language well takes time and effort and you have to start somewhere. Subsequent weeks will require you to work through various chapters of the workbook. You will find that as you progress you will want to skip ahead to different sections, especially once the assessments are released and you want to include specific functionality in your coursework. So after about chapter 3 I expect that many of you will navigate your own path through the remainder of the workbook. The only proviso is that you should aim to have worked through every chapter by the end of the module.




%%%%%%%%%%%%%
%%%%%%%%%%%%%
%%%%%%%%%%%%%       NOTES
%%%%%%%%%%%%%
%%%%%%%%%%%%%




%\part{Notes}


%%%%%%%%%%%%%
%%%%%%%%%%%%%
%%%%%%%%%%%%%       LABS & PRACTICALS
%%%%%%%%%%%%%
%%%%%%%%%%%%%


\part{Labs \& Practical Work}
\chapter{Learning Environment Part \#1}
\label{lab1}
\paragraph{} Because Linux is one of the most widespread operating systems found on web-servers it makes sense for us to use a form of Linux as our \emph{learning environment} for this \emph{Advanced} web technologies module. 

\paragraph{} There are a lot of different versions of Linux, known as \emph{distributions} or \emph{distros}, and you might have heard or or even used some of them, for example, Debian\footnote{\url{http://debian.org/}} or Ubuntu\footnote{\url{ubuntu.com}}. Because we could spend an entire year learning about Linux, and still have more to learn, we shall use a deliberately simplified and stripped down installation of a Linux environment, the Ubuntu Server Edition. The main thing you will notice to begin with is the absence of a Graphical User Interface (GUI). Most web servers, in fact most servers in general, are administered from the command-line (or terminal) using text commands so in this module we'll build some experience of this aspect of modern computer use. The reason for this is that the more hardware and software you have installed on a server, then the more there is to go wrong and each place can interact in complex and hard to disentangle ways. If you only have what is absolutely necessary for your server to run and do it's job and nothing more then you have a simpler environment to bug-fix in and one which should be less error prone and more robust.

\begin{framed}
\textbf{VERY IMPORTANT} Do not install a desktop environment or any graphical tools to your learning environment once you have access to it. Our virtual machines are set up to be lightweight and robust. A GUI will use too many resources, impacting upon other users, and will affect the security and backup software that keeps our virtual infrastructure ticking along nicely. If you do do this, then within a few hours I will get an email from Information Services telling me which machine is a problem, and your machine may be wiped and replaced with a fresh copy. So, opt for an easy life and learn to love the command line ;).
\end{framed}

\paragraph{} We shall also ignore many aspects of working with Linux, such as administration of Linux servers, so that we can focus on using Linux within the context of web-development. Our focus will be on the development of web-apps and an in depth investigation of what happens on the server side. That said, whilst we won't focus as much on the client, there is plenty of scope within the courseworks to put into practise your previous learning from the Web Techologies module from last year to make things pretty and provide a better user experience.

\paragraph{} There will be a number of core steps involved in getting acquainted with the learning environment:

\begin{enumerate}
\item Linux Development Server - Our Ubuntu Linux Virtual Machine which runs on the ENU virtual infrastructure. Each of you will be provided with the address of a specific virtual machine which is your personal learning environment. You will be able to log into this machine using your regular Napier credentials (matriculation number and password) just like you log into regular desktop machines on campus. Your VM is a basic Ubuntu server installation so we will have to install additional software as we go along. However you only have a limited virtual hard-drive so try to restrain yourself from going wild. As a result, you will have access to the \emph{sudo} command to enable you to manipulate your VM as a root user. This means that you can do anything you like to the VM which includes breaking it beyond repair\footnote{If you do break your VM then contact me and I will ask Information Services to reset it. This means that everything on your VM that is not backed up will be lost -- so keep backups (ideally keep all your work in Git and make copious notes as you go along)}.
\item SSH - To enable us to connect from our Windows desktop machine to our virtual Linux machine
\item CLI - The Command Line Interface (CLI) where we'll type commands
\item Vim - This is our \emph{non-graphical} editor that we shall use to write our source code and to edit configuration files. There are lots of command line editors available. Pico and Nano are alternatives, and you are welcome to use whichever command line editor you like. However, this workbook will assume that your default editor is Vim and so your might have to adjust some commands and procedures as a result of using something different. Note that there is a good reason to have some ability to ues Vim; it is one of the most prevalent editors to be found on servers. So if you are dumped on a remote server and need to fix something, Vim is one tool that you can usually expect to find\footnote{This applies to Unix, Linux, MacOS, etc. servers. Basically nearly all servers, except Windows. If you're on Windows then all bets are off. But who deploys a web site to a Windows server?}.
\item Git - We shall use Git to store our source code and as part of the ``hand in'' for our coursework assignments. You will need to put your final project work into a Git repository and zip it up then upload that zip archive to the Moodle link. The reason for this is that there are various levels of internal and external moderation of assignments that occur and having everything in one place makes these moderation processes operate more smoothly. You are also encouraged to make a backup of your repository to another location, e.g. your own laptop, GitHub, GitLab, BitBucket, or wherever. Note that the GitHub and BitBucket interfaces will automatically give you a link to download your repostiory as a zip file which can be useful at submission time.
\end{enumerate}

\paragraph{} By the end of this section of the module you should be able to access your Linux VM by logging in using SSH, navigate around the command-line, use Vim (or similar) to edit your files, and use Git to store your files. This constitutes a core set of tools that should allow you to log into almost any Linux server, whether a very small one running on a Raspberry Pi\footnote{\url{https://www.raspberrypi.org}} or a very large one, for example the top 10 fastest supercomputers in the world all run a version of Linux\footnote{\url{https://top500.org/lists/top500/2022/06/}}, and feel quite at home very quickly. I am not expecting you to achieve all of this in just a single lab session, but you should accomplish this easily within the lab \emph{and} this week's self-study time.

\begin{framed}
\textbf{IMPORTANT} It is a good habit for you to keep notes whenever you are learning a new tool or environment. I keep a textfile on my computer which also means that I can occasionally copy and paste commands if necessary. I also keep a paper-based notebook for more reflextive thoughts and ideas. This way you won't have to immediately remember how you solved a problem but can look how you did it last time. This makes the whole process much less frustrating. It is how I learned to work with Linux and Git and I still refer to my notes every so often when trying to do something that I rarely do and can't quite remember the syntax for.
\end{framed}


\section{Linux Development Server}
\label{linux}
\paragraph{} The university has a heap of server hardware that is used to provide a virtual infrastructure for us. Within this hardware we have a group of virtual machine that has been assembled purely for our use. Our Linux server use the Ubuntu server distribution\footnote{\url{https://www.ubuntu.com}} and has just enough software installed so that we can learn about and get comfortable with a Linux system, but not so many tools that it becomes too daunting. From now on when I refer to the ``dev server'' I shall mean this Ubuntu Linux server in the university's virtual infrastructure.

\paragraph{} Your dev server will give you a launchpad from which to explore the wider world of Unix-style operating systems. If you get comfortable with your Linux server then you shouldn't feel (too) lost trying any other Linux distribution. There are obviously differences between distros, but the the Linux kernel and the GNU userland tools are frequently the core of any distribution.

\paragraph{} What you will notice is that your Linux server is command line only. There is no GUI, no mouse, no point-and-click, and no graphical software. Instead we will have to get used to interacting with the computer using text commands. This is because the vast majority of web servers are text-only. Graphical interfaces provide more complexity, more things to go wrong, and require more hardware to support them whereas we want our web-servers to be robust and performant. Consider this an introduction to how the majority of real-world web-servers exist. There is a very good chance that if you work in any software-centric capacity in the future, then you might have to deal with command-line oriented servers, so why not get used to that now? You might like it.

\paragraph{} Because our server is command line only we'll have to learn some new tools, or at least new ways to interact with tools that we might have already seen, but via GUIs. Eventually your development server will include Python, Flask, SQLite, and Vim, and perhaps even some additional tools installed. We will install them as we go along. By default though you have the standard Linux command line tools. When you log in, the text environment that you are presented with is called a shell and the name of the specific shell we use is called BASH. BASH is, in itself, a programming environment which will run `BASH scripts'. BASH is really useful for whipping up quick bits of code to solve problems, especially those that involve lots of repetition, i.e. the kinds of things that a computer is good at. We will access this server using PuTTY, or any other SSH client using our regular Napier credentials, e.g. your matriculation number and password. You will be able to find out exactly which VM you have access to but all servers will have an address of the following basic form: \url{webtech-YEARCODE-VMNUMBER.napier.ac.uk}, for example, I will be using  \url{webtech-2223-00.napier.ac.uk} as a demonstration environment that matches your learning environment. Note that you won't be able to access any of the other VMs so there is no point in trying. The list of mappings of VM to matriculation number should be available on the module's Moodle page from week \#1. If your matriculation number isn't listed then contact the module leader. The list is generated automatically from enrollment data which isn't always accurate until after the start of the trimester. We'll get into the actual logging in process in just a moment. There are some preliminary things to cover first.

\section{Alternative Learning Environments (optional)}
\label{alternatives}
\paragraph{} If you have a Mac OS or Linux laptop then you can easily install of the tools that we'll use, e.g. Python, Flask, Vim, etc. locally without needing to use the development server. Talk to the module leader or the demonstrator about this. However you should note that you will need to put your coursework assignments onto the development server for the hand-in and demonstration so you should not ignore it until the deadline because this will be stressful for you.

\paragraph{} A second alternative is to install a Linux, like Ubuntu server, into a virtual machine running under VirtualBox on your own laptop. This is quite advanced and will require non-trivial understanding of Linux and virtualisation. For this reason it's not directly supported but is an allowable option for students who are confident of their Linux admin skills. Again though, you will need to put your work onto your Napier VM for demonstration, hand-in, and assessment purposes.

\paragraph{} Finally, you can also, if you really must, install Python and the Flask library onto your Windows machine. However, in this case you should note that the Windows command line is very different to that provided in Linux and Mac OS.

\paragraph{} In all cases, the alternative learning environments are to help you to find a way to work that suits you, but they aren't a short cut to success.

\section{SSH}
\label{ssh}
\paragraph{} SSH which stands for `Secure Shell' is a tool for logging in to remote servers. This means that you get a window on your local machine into which you can type commands. These commands are executed by the remote server and the results are displayed to you in the window on your local machine. We will use SSH to access the dev server. Note that you can run SSH multiple times to provide you with an easy way to get multiple windows so that you can easily multi-task on the remote machine. For example, one advantage of having multiple shells is that we can edit and save a program in one shell and run the program and monitor output in another shell. As you can imagine, this is very useful when we are developing new web apps on the dev server.There are also tools that will manage multiple SSH connections for you.

\paragraph{} If you are on Linux, MacOS, or newer versions of Windows then you will already have a version of SSH installed and all you need to do is open a terminal and type the following to log into your dev server:

\begin{lstlisting}[style=DOS]
    $ ssh MATRICNUMBER@webtech-YEARCODE-VMNUMBER.napier.ac.uk
\end{lstlisting}

\paragraph{} NB. You \emph{MUST} replace MATRICNUMBER with your actual matriculation number from your napier credentials. You also need to replace VMNUMBER with the specific VM number you were assigned and YEARCODE with the academic year, e.g. 2223 for the academic year starting in 2022 and ending in 2023. Note that we should be very careful to type commands accurately, especially the log in command above, and to also to type our password accurately. If we make too many mistakes then the security service on the server will ban you for a period of time. This is a protection to stop attackers from trying multiple attempts at our passwords in order to gain access to the machine. Currently the security setup is quite sensitive, about 2 failed login attempts can get you banned from logging in for about 5 minutes.

\paragraph{} You will be asked for your password but note that the characters of your password won't be shown on screen when you type it in. In fact nothing is shown. This is expected and desirable behaviour and means that someone who is shoulder surfing you cannot determine even how long your password is merely from viewing your screen.

\begin{figure}[H]
\centering
\includegraphics[width=0.75\textwidth]{images/cli_ssh_session_login.png}
\caption{Logging into a remote webtech VM using the command line version of SSH. This will be a similar process across multiple operating systems and is illustrated here using the Windows terminal version.}
\label{fig:cli-ssh-session-login}
\end{figure}


\paragraph{} Alternatively, if you're on an older version of Windows or a lab machine that is misconfigured to not enable the SSH tool in the terminal, then you will need to download an SSH client\footnote{I daresay that with all of the other command line tools and workflows we're looking at in this module, you might also just want to balance things out by using a graphical tool instead. Your choice.}. A popular client for Windows is called PuTTY\footnote{\url{http://the.earth.li/~sgtatham/putty/latest/x86/putty.exe}}. There is also a link to a cached copy of PuTTY from the module web page and it should also be available through AppsAnywhere. Download PuTTy, put it somewhere safe where you can access it then double click it to run. There is no need to install PuTTY as it is very portable. When PuTTY runs you will be presented with the following screen:

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{images/putty_empty.png}
\caption{The PuTTY Window after you load it}
\label{fig:putty-empty}
\end{figure}

\paragraph{} or like this when you've added your VM address to the \emph{Host Name} textbox (again remembering to replace MATRICULATION with your actual matriculation number and NUMBER with your VM ID:

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{images/putty_complete_vm.png}
\caption{The PuTTY Window with completed connection details for the development server}
\label{fig:putty-complete}
\end{figure}


\paragraph{} In either case you might be presented with a window similar to the following, especially if this is the first time you are logging into the remote server:

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{images/putty_alert.png}
\caption{The PuTTY alert Window}
\label{fig:putty-alert}
\end{figure}

\paragraph{} If so, you can just click the `Yes' button (but should read and try to undestand what it is saying). If all goes well and you are on campus then you will be presented with a window containing a command line interface at which you can work. This Window is a connection directly to your VM and anything you do there is actually happening across the network on a remote piece of hardware. If you are off campus then you will likely be presented with a login window for the dev server and all you have to do is type in your ENU password to authenticate. Again, be accurate so that you don't temporarily lock yourself out. After all this you should then be presented with a command line shell on your dev server. Note that some details may vary depending upon which OS you are accessing your dev server from and depending upon your user name. The following is only indicative of what to expect:

\begin{figure}[H]
\centering
\includegraphics[width=0.75\textwidth]{images/putty_login.png}
\caption{The dev-server login Window}
\label{fig:dev-server-login-window}
\end{figure}

\paragraph{} Remember, you can repeat this process with PuTTY as many times as required to get yourself enough shells into the development server to make things easier to work with\footnote{This is not the best way to work with multiple shells. Another, more powerful way is to use a shell multiplexer, my favourite is one called Screen (\url{https://www.gnu.org/software/screen/}) (Tmux is an alternative that is popular) but these are yet more tools to learn, and another set of commands, so lets try to keep things \emph{reasonably} simple for now. Being aware that these things exist though means that when you really need them you know that there is a tool out there waiting for you.}. Alternatively you can use a different SSH client tool, there are many for Windows and some have useful features, like managing multiple connections. Alternatives include the following, but there are many more, Bitvise SSH Client\footnote{\url{https://www.bitvise.com/index}}, MobaXTerm\footnote{\url{https://mobaxterm.mobatek.net/}}, MremoteNG\footnote{\url{https://mremoteng.org/}}, secureCRT\footnote{\url{https://www.vandyke.com/products/securecrt/}}, and Solar Putty\footnote{\url{https://www.solarwinds.com/free-tools/solar-putty}}. PuTTy is fairly basic in terms of functionality but others, such as Bitvise and MobXTerm enable you to create and manage multiple connections to your VM to make it easier to work. For example, having one connection devoted to an editor, another devoted to the CLI, yet another devoted to Git, and perhaps another devoted to executing the Flask debug server. Note that not all of these are free however, but some have a demo, evaluation, or community version that you can use. The moral here is to try things out, see what works for you, and care about the tools that you learn to use.

\begin{framed}
\textbf{IMPORTANT TIP} I usually use SSH to log in at least twice. This gives me a window to edit text in and a window to test my code in. Often I will also have a third window open which I use for command line interaction, Git commits, and testing API calls using cURL, but two is the minimum for a nice development setup - Remember, this is your development environment so you might as well take some time to set it up nicely and so that you can work more productively.
\end{framed}

\paragraph{} You will, at some point, encounter errors or difficulties whilst logged into your remote machine. In order to get support, and also to provide information to support your helpers, it can be useful to provide information about the commands you have run and the results of doing so. It turns out that PuTTY can help you to do this. PuTTy has a logging option which will automatically create a log file of your SSH session but it is off by default. You can enable logging by clicking the ``All session output'' option in PuTTY's configuration. You can find this option in the Category $\to$ Session $\to$ Logging tab of PuTTY. You'll then have a file that you can attach to emails when asking for support. Note the other options in the PuTTY interface though, specifically the ones for automatically creating different named log files using, e.g. date, time, and hostname information, so that your session log is automatically named with a sensible identifier.

\begin{figure}[H]
\centering
\includegraphics[width=0.5\textwidth]{images/putty_logs.png}
\caption{The PuTTY logging options. Select ``All session output'' to keep an automatic log of your session.}
\label{fig:putty-logging-options}
\end{figure}



\section{Basic Linux Usage}
\label{linux}

\paragraph{} When we first log in to Linux we will see a prompt, a place where we can type commands. It looks something like this (again, your specific VM might have a different name so might not \emph{exactly} match this):

\begin{lstlisting}[style=DOS]
    40001111@soc-web-liv-12:~$ 
\end{lstlisting}

\paragraph{} This simply means that the user `40001111' is logged into the machine called `soc-web-liv-12'. The `:' is merely a separate between the user@machine part of the prompt\footnote{You can customise your prompt to display just the information that you want to be displayed, but this is left as an exercise for you} and the next part `{\raise.17ex\hbox{$\scriptstyle\sim$}}' which is your current location in the filesystem. The tilde or `{\raise.17ex\hbox{$\scriptstyle\sim$}}' symbol is used on Linux machines to mean your home directory. Finally the `\$' symbol is your ``prompt'', the place where anything you type will be displayed.

\paragraph{} Note that in the remainder of this workbook, we'll just show the `\$' part of the prompt to simplify the examples.

\paragraph{} Linux has a file system, a way for all of the files that make up the running system to be organised hierarchically, just like Windows. However, on Linux the file system is organised a little differently. Instead of starting at `C:' the Linux file systems starts with `/' which is also known as the ``root'' of the filesystem. The word root is used because the Linux filesystem is shaped like a tree. All of the resources that you can access, such as your own files, are located at some level somewhere within the tree. An advantage of the Linux approach is that, when you add extra hard-drives, or mount network resources, instead of extra drive letters, all of your resources get mounted within the tree, e.g. /volumes/web might be the path to a remote web server and /media/cdrom might be the path to your CD-Rom drive\footnote{if you still have such an old-fangled device}. But other than that, from a basic user-oriented perspective, both Windows and Linux file systems are a hierarchical collection of files and directories in which any given directory might contain zero or more files or child directories.

\paragraph{} When you log in you will be located in your own directory, called your ``home'' directory which is located in the filesystem tree at 

\begin{lstlisting}[style=DOS]
    /home/YOUR-MATRIC-NUMBER
\end{lstlisting}
\paragraph{} You can always see where you are in the filesystem by typing

\begin{lstlisting}[style=DOS]
    $ pwd
\end{lstlisting}
\paragraph{} which is short for ``print working directory'' or ``tell me where I am''. The pwd command will give you the full hierarchical list of folders, from the root, to your current location in the file-system. You can type this anywhere you have a prompt. Also, no matter where you navigate to within the file system you can always return to your home directory by typing:

\begin{lstlisting}[style=DOS]
    $ cd
\end{lstlisting}

\paragraph{} You can navigate around the file system using the cd command which is short for `change directory'\footnote{You'll notice that many Linux commands are shortened versions of longer words. This is partly designed to reduce the amount of typing that you do. It may seem silly now but when you are changing directory hundreds of times a day it is much nicer to type cd than change-directory each time.}. The default version, without an argument takes you home, as we said before, but if you supply an argument then you can change the current directory. Let's try that now by changing to the root of the filesystem:

\begin{lstlisting}[style=DOS]
    $ cd /
\end{lstlisting}
\paragraph{} If you now use pwd you should see that the output is different to what it was before. You are no longer in your home directory but are in the root directory instead. Now ues the cd command without an argument to go home and use pwd to see where you are again. You can also step up through the directory hierarchy by using the `..' argument:

\begin{lstlisting}[style=DOS]
    $ cd ..
\end{lstlisting}
\paragraph{} `..' is an \emph{alias}, a label that has a default meaning, which in this case means ``move into the parent directory''. Explore the filesystem for a while using the cd, cd /, cd .., and pwd commands.

\paragraph{} There is a limit to what we can do with just these commands because we can only move into our home directory, or else navigate up through the tree to the file system root directory. We need a couple more commands to let us see what is inside a directory and to move into a new directory. For this we use the `ls' command which is short for list or list contents to see what files or child directories are in our current directory, and the cd command but with the name of a child directory as the argument. So, we can use `ls' as follows:

\begin{lstlisting}[style=DOS]
    $ ls
\end{lstlisting}

to list the files in the current directory. If you try this now you will be able to the files in your own home directory. There will probably be none at this point but don't worry, that will soon change. My test account for the dev server gave the following output:

\begin{lstlisting}[style=DOS]
    $ ls
    test  test.py
\end{lstlisting}

\paragraph{} Now we can create new files in our home directory quite easily using touch, e.g.

\begin{lstlisting}[style=DOS]
    $ touch testfile.txt
\end{lstlisting}

\paragraph{} which should give us something like this:

\begin{lstlisting}[style=DOS]
    $ ls
    testfile.txt
\end{lstlisting}

\paragraph{} We can also create new directories using the `mkdir' which means make directory
\begin{lstlisting}[style=DOS]
    $ mkdir testdirectory
\end{lstlisting}

\paragraph{} which results in

\begin{lstlisting}[style=DOS]
    $ ls
    testdirectory/    testfile.txt
\end{lstlisting}

\paragraph{} We can also move files around using the `cp' and `mv' commands which are short for ``copy'' and ``move'' respectively. Let's see them in action; first we will make a copy of testfile.txt then move the copy into the testdirectory:

\begin{lstlisting}[style=DOS]
    $ cp testfile.txt testfile2.txt
    $ ls
    testdirectory/ testfile2.txt  testfile.txt
    $ mv testfile2.txt testdirectory/
    $ ls
    testdirectory/    testfile.txt
    $ ls testdirectory/
    testfile2.txt
\end{lstlisting}

\paragraph{} Notice that in this example we passed an argument, the name of a directory `testdirectory' to the ls command and this caused the contents of testdirectory to be listed instead of the current directory. We can do that with any directory that we have access to.

\paragraph{} Finally we might want to delete files to keep things tidy. We can use the `rm' command to remove files, e.g.

\begin{lstlisting}[style=DOS]
    $ rm testfile.txt 
    $ ls
    testdirectory/
\end{lstlisting}

\paragraph{} We can use also use rm to remove directories, however, by default we get this behaviour:

\begin{lstlisting}[style=DOS]
    $ rm testdirectory/
    rm: cannot remove 'testdirectory/': Is a director
\end{lstlisting}

\paragraph{} What we need to do instead is to supply some options to the rm command. We need rm to act recursively, that means move into the specified directory and delete its contents and we also need to force rm not to stop and ask us for each file whether it should be deleted. We there fore need to use rm as follows:
\begin{lstlisting}[style=DOS]
    $ ls
    testdirectory/
    $ rm -rf testdirectory/
    $ ls

\end{lstlisting}

\paragraph{} Of all the commands we have met so far, rm is the only one that can do any real damage. rm -rf could conceivably delete all of your files and directories if the command is executed in the wrong place. As a result you should, especially once you start writing code on the dev server for your assignments and lab exercises, keep backups of anything that you will need to use again. This goes twice for the code for your coursework assignments. Note that one of the tools we'll learn later, Git, is specifically designed to help you back up your code to other locations, such as GitHub or BitBucket so the best thing to do is to learn to use Git well rather than looking for non-standard alternatives.

\paragraph{} There are many, many more commands than just these. In fact you can do much more with the command line than you can with graphical tools. However, this should be enough for you to get started and is enough for you to be able to create and delete files and directories, to navigate the file system hierarchy, to list the contents of directories, and to view the contents of files. 

\paragraph{} To do more exploration of Linux, you can of course experiment on the dev server. Your account is quite limited in what it can do so you shouldn't be able to do too much damage. Another good place to start is the Linux Zoo site\footnote{\url{http://www.linuxzoo.net}} which offer online virtual machines, more information, and a number of tutorials. Particularly the Linux Zoo ``essential Linux'' pages\footnote{\url{http://linuxzoo.net/page/intro.html}} which explain in more depth some of the tools that we have already covered plus many many more.




\section{Vim}
\label{vim}
\paragraph{} Vim is a command-line based text editor. It is based on an earlier editor called Vi (Vim is VI improved, hence Vim, which is a little easier to use). You might ask why we don't just use a GUI text editor like Notepad, or the editor in Visual Studio. The main reason is because we are talking about advanced web technologies, and dealing with them often involves accessing remote servers. Furthermore, the majority of servers do not have a graphical interface and only have installed the most minimal and robust set of tools. The one editor that you are almost guaranteed to find on any Unix or Linux server is Vi and by learning Vim you are well placed to handle Vi. As a result it makes sense for us to become familiar with it. Many of us actually find that the shortcuts and powerful control that Vim offers us mean that we just concentrate on learning one editor very well and only use that editor rather than moving to a different editor each time we need to write a different type of document or program in a different language. That all said, if you really struggle with VIM, then your VM already has the slightly simpler command line editors, nano and pico installed. You can run either by typing it's name at the terminal. Note that these have an on-screen menu to remind you of the core editing functions available and they are accessed via a key combination such as \string^X, which is the combo for exiting nano (The `\string^' in this case means the ctrl key on your keyboard and not the caret sigil above the number 6).

\paragraph{} What makes Vim different from many of the editors that you will be familiar with, like Notepad, is that there is no role for the mouse, no buttons to click at all, only keyboard shortcuts, so we shall learn just enough of those in this module to be able to edit basic documents\footnote{However there are hundreds of Vim commands and a really clever things is that most of the commands can be chained together so that you can automate many editing tasks.}. A second very important aspect of Vim is that it is a \emph{modal} editor. When you use Vim you use it in different modes, when you are typing content into a file then you are in edit mode, and when you are entering commands you are in command mode. When Vim starts it is in command mode and anything you type will be interpreted as a command for Vim to perform. You switch into edit mode by typing `i' (for insert) and you can return to command mode at any time merely be hitting the escape key.

\begin{framed}
\textbf{IMPORTANT} If you are ever unsure what mode you are in the you can just hit escape a couple of times to ensure you are in edit mode. From here you can just type `i' again to enter the edit mode.
\end{framed}

\paragraph{} Start Vim by typing Vim at the prompt:
\begin{lstlisting}[style=DOS]
    $ vim
\end{lstlisting}
\paragraph{} and you will see something similar to the following:

\begin{figure}[H]
\centering
\includegraphics[width=0.75\textwidth]{images/vim_first.png}
\caption{The default Vim Editor window}
\label{fig:vim-first}
\end{figure}

\paragraph{} Let's do the easiest thing first. Let's quit Vim. To do this we enter the command mode by hitting escape then enter `:q' (where is q is short for quit) and hit enter, e.g.

\begin{lstlisting}[style=DOS]
    <ESC>:q<ENTER>
\end{lstlisting}
\paragraph{} Your Vim window should look something like this when the command is entered (but before you press enter):

\begin{figure}[H]
\centering
\includegraphics[width=0.75\textwidth]{images/vim_quit.png}
\caption{The Vim Editor with `:q' command entered}
\label{fig:vim-quit}
\end{figure}

\paragraph{} Once you hit enter you will be dumped back to the Linux prompt. Two other useful commands to be aware of for quitting are as follows:

\begin{itemize}
\item To quit and discard any changes, i.e. if you have already made changes to a document that you don't want to save:\\
\begin{lstlisting}[style=DOS]
    <ESC>:q!<ENTER>
\end{lstlisting}
\item To quit and save changes, we use :wq for (w)rite and (q)uit:
    \begin{lstlisting}[style=DOS]
    <ESC>:wq<ENTER>
\end{lstlisting}
\end{itemize}

\paragraph{} Let's start Vim again and actually edit some text. This time when Vim starts you need to press `i' for (i)nsert to enter the edit mode. You can now type away to your hearts content. When you are ready to save the file you can enter the command mode and type :w for (w)rite. If the file doesn't have a filename you will get a message to that effect so, with a new file that isn't yet saved you can us :w filenname.txt (where filename.txt is the name of the file that you want to create). This file will then be created in whichever directory you were in when you started Vim.

\paragraph{} There is \textbf{A LOT} to learn in Vim. All those shortcuts are really a language for manipulating text. The easiest way to learn Vim, just like any new tool, is to use it. There are also many online resources that teach you how to use Vim but two of my favourites are:
\begin{enumerate}
\item The Open Vim Tutorial: \url{http://www.openvim.com/}
\item Vim Adventures: \url{http://vim-adventures.com/}
\end{enumerate}

\paragraph{} I recommend visiting those site and particularl trying some of the exercises to get used to some of the core Vim functionality. There is also a cribsheet of useful commands in section \ref{cribsheet_vim}.

\section{Git}
\label{git}
\paragraph{} Git is a source control system that enables you to keep track of your source code, its history and any changes you make. Git can be used to track any file but is most efficient and best suited when used only with textual files. Because Git is a \emph{distributed} source control system it works very well to enable groups of people to work on the same source code as well as supporting experimenting with your code, trying out lots of different ideas in separate \emph{branches} (which are a bit like a copy of your code but with tools to help manage that copy and support re-integrating it with your main source tree if you want to), and being able to roll back to an earlier version if you decide you have take a wrong turn.

\paragraph{} Whilst you might have seen Git before, perhaps as a plugin to an IDE or as a standalone GUI app, Git is primarily a command line application, so we shall use it to get our source code in and out of the dev server.

%\begin{framed}
\textbf{IMPORTANT} We shall use Git to support the hand-in of courseworks in this module so you should get familiar with it as soon as possible. A good place to start is by dipping into the Git SCM book\footnote{\url{http://git-scm.com/book/en/v2/Getting-Started-About-Version-Control}}.

\paragraph{} There are also numerous interactive tutorials and resources to help you get started with Git:
\begin{enumerate}
\item The Git Parable: \url{http://tom.preston-werner.com/2009/05/19/the-git-parable.html}
\item Github's Learn Git 15 minute tutorial: \url{https://try.github.io/levels/1/challenges/1}
\item Learn Git Branching \url{http://pcottle.github.io/learnGitBranching/}
\item Git Immersion \url{http://gitimmersion.com/lab_01.html}
\end{enumerate}

\paragraph{} You should also create either a Github account\footnote{\url{https://github.com/}} or a Bitbucket account\footnote{\url{https://bitbucket.org}} (or both if you like) then create a repository within your new account called `set09103'. You will push all of your code throughout the module into this repository and at hand in time I will pull a copy for marking. The advantage of this appraoch is that at any point, if you need help with your code, then we have a copy that I can see remotely. However this only works if you keep adding your code to your repository. That means whenever you make changes you need to (1) add them, (2) commit them with an explanatory message,  and (3) push the changes from your local repository to the shared one on Github or Bitbucket.

%\end{framed}

\paragraph{} Git is already installed in our learning environment. In order to use it we have to do a couple of things. Log into the dev server then do the following (obviously replace my email address and name with your own):
\begin{lstlisting}[style=DOS]
    $ git config --global user.email "s.wells@napier.ac.uk"
    $ git config --global user.name "Simon Wells"
\end{lstlisting}

\paragraph{} It is easiest to create a new repository through the interface on Github or Btbucket then use the repository cloning address to make a local copy as this sets up all the addresses automatically for pushing and pulling code. Once a repository is set up and you have cloning address you can do something similar to the following (where \url{https://siwells@github.com/siwells/sandpit.git} is the name of one of my repositories on github, your's will obviously be different):

\begin{lstlisting}[style=DOS]
    $ git clone https://siwells@github.com/siwells/sandpit.git
\end{lstlisting}

\paragraph{} We can then make changes within the new local clone of, in this case the `sandpit' repository, then add, commit, and push as follows (again the details of adding and committing depend upon the exact files that you have altered. In this case we'll assume that a file test.txt has been edited):

\begin{lstlisting}[style=DOS]
    $ git add .
    $ git commit -m "Added introductory example"
    $ git push
\end{lstlisting}

\paragraph{} Again, as for Linux and Vim, there are many options and powerful features that you can learn to use with Git, however we shall try to keep things as simple as possible for now.

\begin{framed}
\textbf{ADVANCED} If you are comfortable with using Git and SSH then you might want to try setting up SSH keys so that you don't have to use a password each time you push code into your remote repository.
\end{framed}

\section{Wrapping Up}
\label{chapter_01_wrap-up}
\paragraph{} Obviously this has only been the most basic of introductions to web development using a Linux server. There is much much more that you could learn about any one of the tools that we have introduced and it is well worth your time to explore additional resources and reading for each of them. It is very likely that you will experience some or even all of these technologies, in some form, at some point of your career and putting in some extra effort now will mean that you are much more capable later.

%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%
% CHAPTER 2
%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%

\chapter{Learning Environment Part \#2}
\label{lab2}
\paragraph{} After last weeks extravaganza of new tools, we will only introduce two new tools this week, the Python language and a Python Library for developing web applications called Flask. By the end of this weeks practical work you should be able to build a simple `Hello Napier' web app using Python and Python-Flask which is hosted on and runs within our learning environment and whose source code is pushed to our personal Github (or Bitbucket) repositories. 

\paragraph{} In total, by the end of this week we should all have at least some rudimentary experience with each of the following software tools:

\begin{enumerate}
\item Linux Development Server - Our Linux server which runs on the ENU virtual infrastructure.
\item SSH - To enable us to connect from our Windows machine to our virtual Linux machine
\item CLI - The Command Line Interface (CLI) where we'll type commands
\item Vim - This is our \emph{non-graphical} editor that we shall use to write our source code. 
\item Git - We shall use Git to store our source code and to ``hand in'' our coursework assignments
\item Python - A general purpose programming language that is well suited to web development.
\item Python Flask - A Python library for server-side web-app development.
\end{enumerate}

\paragraph{} This constitutes our entire learning environment. If you have missed any part of the learning environment then it is worth going back and filling in any gaps as they all work together to give us a solid foundation for the development of professional development skills and the production of robust and scalable web-apps. In other words....

\begin{framed}
\textbf{VERY IMPORTANT} The work this week builds directly on last week so if you haven't finished working through chapter \ref{lab1} then it is best to do that first or you will probably get horribly stuck.
\end{framed}

\section{Python}
\label{python}
\paragraph{} Python\footnote{\url{https://www.python.org/}} is a very useful programming language and much of its popularity stems from the fact that it is easy to get a lot done with having to write too much code. We already have Python installed on the dev server ready to use. We can run Python by typing its name in the terminal, e.g.

\begin{lstlisting}[style=DOS]
$ python3
Python 3.8.2 (default, Jul 16 2020, 14:00:26) 
[GCC 9.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>>
\end{lstlisting}
\paragraph{} This starts the Python Read-Evaluate-Print-Loop or REPL in which we can type Python commands and get immediate output. To exit the REPL we type `quit()' which will return us to the Linux shell, e.g.

\begin{lstlisting}[style=DOS]
$ python3
Python 3.8.2 (default, Jul 16 2020, 14:00:26) 
[GCC 9.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> quit()
$ 
\end{lstlisting}

\paragraph{} Here is the traditional `Hello Napier' program in Python (try it out for yourself):

\begin{lstlisting}[style=DOS]
$ python3
Python 3.8.2 (default, Jul 16 2020, 14:00:26) 
[GCC 9.3.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> print("Hello Napier")
Hello Napier
>>> quit()
$
\end{lstlisting}

\paragraph{} The REPL is very useful for trying out bits of Python as you are learning and also for interactively developing code and analysing data. There are super-charged REPLs and related tools such as iPython\footnote{\url{http://ipython.org/}} and iPython notebooks\footnote{\url{http://ipython.org/notebook.html}} which are used in data science and data analysis. However, once we are comfortable with the Python syntax, we will mostly want to run Python scripts, so let's do that.

\paragraph{} Create a new file called first.py, open it in Vim then edit it as follows:

\begin{lstlisting}
print("Hello Napier")
\end{lstlisting}

\paragraph{} Save and close first.py then execute the following command in the shell:

\begin{lstlisting}[style=DOS]
    $ python3 first.py 
    Hello Napier
\end{lstlisting}

\paragraph{} Congratulations. Another first. You just ran your very first Python script. All we will really do from now on in the remainder of this module is build on top of this basic script in order to build our own web-apps. However, we shall have some help along the way from some really excellent libraries so don't worry, we shan't build everything from scratch.

\paragraph{} Now the best thing to do is to learn some Python syntax by exploring some of the excellent online `learn Python' tutorials that are available. Some of them are interactive, so you can type directly into the web-site and get results. Others just give you exercises to do yourself and you can do those exercises in Python on our dev server platform. Here are a few, in order of usefulness according to me, but many more are just a Google search away:

\begin{enumerate}
\item Learn Python the hard way: \url{http://learnpythonthehardway.org/book/}
\item The Python Practice Book: \url{http://anandology.com/python-practice-book/index.html}
\item A Byte of Python: \url{http://www.swaroopch.com/notes/python/}
\item Code Combat: \url{https://codecombat.com/}
\item Python for you and me: \url{http://pymbook.readthedocs.org/en/latest/}
\item The Hitchhiker's Guide to Python: \url{http://docs.python-guide.org/en/latest/#the-hitchhiker-s-guide-to-python}
\item Hands-On Python Tutorial: \url{http://anh.cs.luc.edu/python/hands-on/3.1/handsonHtml/index.html}
\item The Python Challenge: \url{http://www.pythonchallenge.com/} - Some quite touch challenges that you can solve using Python (NB. Assumes you already know what you are doing)
\item Python Tutor: \url{http://www.pythontutor.com/} - Helps visualise the execution of Python code. Again, assumes that you have some prior knowledge of Python syntax.
\end{enumerate}

\paragraph{} The links towards the top of the list are aimed at those completely new to the Python language whereas those further down the list will help those who have some Python knowledge already. Another good way to practice a new language or to improve your existing abilities, not just in Python, but in any language, is to try to solve a set of problems using the language. I often use Project Euler when starting out with a new language but there are also many others:

\begin{enumerate}
\item Project Euler: \url{https://projecteuler.net/}
\item Stack Exchange Code Golf: \url{http://codegolf.stackexchange.com/}
\item Code kata: \url{http://codekata.com/}
\item Reddit Daily Programmer: \url{https://www.reddit.com/r/dailyprogrammer}
\item Programming Praxis: \url{http://programmingpraxis.com/}
\item Rosetta Code: \url{http://rosettacode.org/wiki/Main_Page}
\item International Collegiate Programming Contest Problems Index: \url{http://acm.hit.edu.cn/judge/ProblemIndex.php}
\item Algorithmist: \url{http://www.algorithmist.com/index.php/Main_Page}
\end{enumerate}

\paragraph{} It is also worth creating a git repository of any code that you create when learning a new language because if you take a break from that language to do something else, you will have somethings to remind you of where you were up to before. It is also a neat way to share your solutions with others. If you exhaust all that lot then another great practice approach is to try to implement your own versions of basic (and advanced) algorithms and data structures. For example, if you really want to challenge yourself, and your knowledge of a programming language, read about and implement probabilistic datastructures like Bloom Filters which I find quite interesting, or Fountain Codes which are used in tools like Bittorrent.

\section{Python-Flask}
\label{python-flask}
\paragraph{} Python-Flask, or just Flask\footnote{\url{https://palletsprojects.com/p/flask/} - This is the main project website for Flask and should be your first port of call for additional information and documentation}, is a Python based microframework for developing websites in Python. Flask is already installed and ready to run. We shall leave all of the nitty gritty of installing and administrating software on a Linux server as an exercise that is outside of the remit of this module and just focus on using the tools that we already have installed.

\paragraph{} Flask includes a lot of useful tools; a development server and debugging tools so that we can run our flask apps during development without needing to run a separate external server like Apache\footnote{\url{http://www.apache.org/}} or NGinX\footnote{\url{https://www.nginx.com/resources/wiki/}}. Obviously if we were deploying our apps in the real world then we would host our web-apps differently. We would use a secure Linux install on a server with access to the external world and would use a good HTTP server, like NGinX, and a WSGI-compliant app-server, like uWSGI\footnote{\url{https://uwsgi-docs.readthedocs.org/en/latest/}}. We might even use a load balancer like Haproxy\footnote{\url{http://www.haproxy.org/}} to enable us to scale our operations. We will look at all of these aspects later in the module but for now we shall concentrate on the development server and a simplified development environment. Flask also has integrated unit-testing support, RESTful request dispatching, templating, to help generate HTML pages, using the Jinja2 tool.

\paragraph{} Flask supports us in building web-apps that conform to the Python Web Server Gateway Interface (WSGI)\footnote{The WSGI standard is described in this Python Pep:\url{https://www.python.org/dev/peps/pep-0333/}. A PEP is a Python Enhancement Proposal and is the main way that the planned development of the Python language progresses.}. The goal of WSGI is to make it easy to develop and deploy Python web-app, regardless of the library that is used. So developers can find a library that they find useful, or helps them to tackled their development task, but the output of the process, the web-app has know features and capabilities which means that any server that supports the WSGI can run the web-app. This is similar to what happened with web-app development in Java, where the servlet API means that many tools can be used to build a Java web-app and many web-servers can then run the app.

\subsection{Installation}
\paragraph{} We should only need to go through this process once. We are going to install some bits of software to enable us to manage python libraries. Flask is a library, but not the only one that we'll use, so having a way to manage different versions of our libraries is a useful thing. It's also the `proper way to do things'. We will use a program called `Pip' to install and manage libraries of Python sourcecode, such as the web library (Flask) that we're using in this module. Pip (or rather `pip3' is already installed on our NapierVM alongside Python so we don't need to install that. However, We will also use a second Python tool that is used to manage sets of Python libraries, so that we can use different versions of libraries for different projects without them all interfering with each other. This tool creates a `virtual environment' for our python web apps to run in and makes sure that the right versions of the right libraries are available to our web-app. The tool we'll use is called `VirtualEnv' and we can install it like so:

\begin{lstlisting}[style=DOS]
    $ sudo apt install virtualenv
\end{lstlisting}

\paragraph{} Again you might be asked for a password and whether you want to continue. Enter your password and type `y' when, and if, prompted. When this has complted successfully, we should have our prompt back and both the pip and virtualenv tools will now be available. Each can be invoked by typing it's name at the prompt. They won't do much yet though. 

\paragraph{} We can create a virtualenv using the virtualenv command and passing it the name of the environment we want to create. For example, to create an environment called `test' we could do the following:
\begin{lstlisting}[style=DOS]
    $ virtualenv test
\end{lstlisting}

\paragraph{} Once a virtualenv is created we need to activate it, like so:
\begin{lstlisting}[style=DOS]
    $ source test/bin/activate
\end{lstlisting}
\paragraph{} This basically changes where Python looks for the libraries that it can use. We can also use the pip freeze tool to see what libraries are installed, like so:

\begin{lstlisting}[style=DOS]
    $ pip3 freeze
\end{lstlisting}

\paragraph{} I don't see Flask amongst the list of installed libraries. Perhaps we'd best install it? We can do that using pip, like so:

\begin{lstlisting}[style=DOS]
    $ pip3 install Flask
\end{lstlisting}

\paragraph{} If you run pip freeze again you will notce that a bunch of new libraries are installed, these include both Flask and a bunch of supplemental ilbraries that Flask uses.

\paragraph{} When we are done working within a Python virtualenv we can close it down by using the deactivate command like so:
\begin{lstlisting}[style=DOS]
    $ deactivate
\end{lstlisting}

\paragraph{} You will need to activate and deactivate your virtualenv whenever you want to run your web-app (or use any of the libraries installed within the virtualenv). When we come to deploy our web-apps for live consumption on the web, we'll set things up to work automatically though, but that comes later. Note that you should only need to install pip and virtualenv once. They will then be installed and available permanently on your VM. You can then create as many virutalenv's as you want or need. One for each project or experiement seems like a good rule of thumb.

\paragraph{} To manage virtualenvs I usually create a folder for each of my Python projects. I then navigate into that folder and create a new virtualenv within it. I usually name each virtualenv as just `env'. When I want to work on a project I just cd into the project folder then `source bin activate' to start the environment. From this point on, until I type deactivate, Python within the current window will use the activated virtualenv. Note that you can run multiple virtualenvs but they must be in different login windows\footnote{or screen or tmux buffers}. This will all seem complicated for now, but you will get used to it and it gives you much more control over your development projects as things develop. You can, and should, read more about virtualenvs. One place to start is in the ``Hitchikers Guide to Python''\footnote{\url{https://docs.python-guide.org/dev/virtualenvs/\#lower-level-virtualenv} - This whole section should be quite interesting and is well worth reading, especially the bit about using pip freeze to create a requirements.txt file, basically a list of libraries that your code uses, so that you anyone who you give your code to can recreate the environment to run it in. Really useful, and efficient because we then don't need to distribute the libraies that our code needs to run, just the code itself.}.

\paragraph{} Assuming that your virtualenv is activated, and that you've got Flask installed (reactivate your virtualenv if not), you can check whether a library, like Flask, is installed by running the following:

\begin{lstlisting}[style=DOS]
    $ python3 -c "import flask"
\end{lstlisting}

\paragraph{} This just invokes Python and tell it to use the `compile' mode and to take the code that is passed in as an argument, in this case just the Python code to import the flask library. Importing is just our way to tell Python that we want to use a particular library for our code. If the library is available then there will be no output, so if there are no errors or other messages displayed then everything is fine and you can move on. If you do get errors or messages then it might be worth doing some background research to increase your knowledge before asking for help.

\section{Python Flask ``Hello Napier''}
\label{hello-napier}

\paragraph{} Now we can get on with actually building our first web-app using Python and Flask.

\paragraph{} Here is our first Python Flask app. You'll find an annotated version in Appendix \ref{annotated_hello_napier} that explains what each line is doing, but see if you can work that out yourself first:

\begin{lstlisting}
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello Napier'
\end{lstlisting}

\begin{framed}
\textbf{IMPORTANT} Don't just copy and paste code from the PDF. This is for two very good reasons. The first is that Python is `white-space sensitive'. This means that Python uses whitespace as part of the layout of code, instead of using things like curly braces such as `\{' and `\}'. So if you get spaces, tabs, and other whitespace characters mixed up in your file, which can easily happen if you copy and paste, then it will affect the indentation of the file (although perhaps not in a way that you can tell visibly because whitespace can all look pretty much the same). The second very good reason is that typing in the code counts as `deliberate practise'. You are more likely to remember stuff if you do it multiple times and typing it in the first time counts as the first opportunity to practise.
\end{framed}

\paragraph{} Type in the `Hello Napier' code from above or else get it from the module's Git repository. Save the code in a file called \emph{hello.py}

\paragraph{} Now enter the following commands into the terminal:

\begin{lstlisting}[style=DOS]
    $ export FLASK_APP=hello.py
    $ export FLASK_ENV=development
\end{lstlisting}

\paragraph{} where ``hello.py'' matches the name of the Flask web-app's file name. NB. In this case it should actually be ``hello.py'' but later on you will run web-apps that are stored in files with different names. This basically telling the flask library/runtime which file to use as the entrypoint for our flask app and which \emph{mode} to use for deploying our app. In this case we are developing an app so we want to see as much debug information as possible. When deploying live to end-users we would not want to have the development environment enabled though.

\paragraph{} Note that you only need to set these exported variables once at the start of each development session, i.e. when you log into your VM. After that they will stay available until either you log out or you change them, in which case they either become unset (if you log out) or are altered (if you change them). If you want to set them permanently then the you can do that through your .profile file which is a hidden file in your home folder on your VM. You should do a little research before hand however as the .profile file is really very useful and powerful. Similarly you could also write a short script to set your environment variables that is either run when you log in, or when you activate your python virtualenv, or manually when you execute it. Again, this is something that will require a bit of extra research, but Linux scripting is incredibly powerful and a skill that is well worth adding to your toolbox.

\paragraph{} Having set everything up we can now run our code by executing the following command in the same directory where hello.py is stored:

\begin{lstlisting}[style=DOS]
    $ python3 -m flask run --host=0.0.0.0
\end{lstlisting}

\paragraph{} The host argument merely causes our web-app to be available publically. If we didn't include this then we would only be able to access the web-app from within the development server. Overall, this command causes our web-app to be run using the Flask development server and to be made available to be accessed from any IP address on the Internet. The Flask development server is really useful and fast for debugging during development. If everything goes well then you should see output similar to the following in your terminal:

\begin{lstlisting}[style=DOS]
    $ python3 -m flask run --host=0.0.0.0 * Serving Flask app "hello.py" (lazy loading)
 * Environment: development
 * Debug mode: on
 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
 * Restarting with stat
 * Debugger is active!
 * Debugger PIN: 211-020-266
 \end{lstlisting}

\paragraph{} Congratulations. You now have your first Python3 web-app running. Flask will now continue to run in your terminal until either an error occurs or you stop it. To stop it you can send the ``SIGINT'' or `interrupt Signal' to flask to tell it to stop itself by using CTRL+c\footnote{This means holding down the CTRL button then pressing the C button whilst still depressing CTRL then releasing both buttons.}.

\paragraph{} When we run a Flask web-app, that app will be accessible in a web browser on a particular network port. By default, Flask runs on port 5000. Your web browser only looks to port 80 be default so we need to tell our browser where to find our app on the given server. You can visit the page generated by Flask in a web browser. Just start up a browser in your host OS, e.g. in Windows when accessing the dev server from a lab machine. Then visit the following address \url{http://webtech-NUMBER.napier.ac.uk:5000} where you have replaced `NUMBER' with your assigned VMs number:

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/flask-hello-napier.png}
\caption{Your first Python Flask web app.}
\label{fig:flask-hello-napier}
\end{figure}


\section{Reading \& Resources}
\paragraph{} This chapter only scratches the surface of Flask. You will find much more information at the Flask project's web page. There are also several sites that explain aspects of Flask and might prove useful. Even if you end up reading the same information a few times, you might find that some voice speak to you better than others:

\begin{itemize}
\item The Flask Documentation\footnote{\url{https://palletsprojects.com/p/flask/}} - The first place to go to for information about the Flask microframework.
\item Full Stack Python Flask Page\footnote{\url{https://www.fullstackpython.com/flask.html}} - A great list of online resources for Python Flask
\item How a Flask app works\footnote{\url{http://pythonhow.com/how-a-flask-app-works}}
\item Miguel Grinberg's Series of articles on Python Flask\footnote{\url{http://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world}} - This became a published book a few years ago and is well worth getting hold of for an end-to-end demonstration of the development of a whole Flask web-app. 
\end{itemize}

\section{Wrapping Up}
\label{chapter_02_wrap-up}
\paragraph{} Right. Thats all the preliminaries in place for building web-apps in our learning environment. We can now run a small and lightweight, but otherwise similar to full Linux installs, virtualised server which will host our web-apps. We can log in to the server using SSH, navigate the Linux environment, and edit files using VIM. We can also take advantage of the installed Python language and Python-Flask web-app library to build our own web-apps.

\begin{framed}
\textbf{CHALLENGE \#1} You should already know how to do this, and this is, as a result, merely some extrac practise. Create a Github or Bitbucket account. Bitbucket allows you to create an unlimited number of private repositories if you use your @napier address to register whereas Github restricts the number of private repos. That said, either site allows you to create as manay public repositories as you like. Create a remote repo in your Github or Bitbucket account called `set09103'. Log into the Linux dev server then clone your set09103 repo. Create a new file in your repo called `hello.txt' and put the message ``Hello Simon'' in it then add, commit and push your changes to your remote repo. Once you have done this, check on either Github or Bitbucket to ensure that your text file is in the repo where you expect it to be then send an email to Simon containing the name of your account, which service, Github or Bitbucket, you are using, and the SSH clone url for your set09103 repository. 

{\emph{If you use a private repository then you will have to add my account as a collaborator. On both Github and Bitbucket my account name is `siwells'}}. 

Note that I won't do anything with this repo, it is just for practise for the moment, and also gives me a sense of how folk are progressing through the workbook.
\end{framed}
\begin{framed}
\textbf{CHALLENGE \#2} We'll build on the Hello Napier app over the next few weeks, but we haven't yet learned to do much more than return a string from our app (which then displays in the browser). Play around with the hello napier app that we created earlier today. What happens when you return other things in the string? Can you work out how to run some different Python code and return the result? What about getting the app to generate a different random message each time the browser page is refreshed? Finally, as you should already know HTML, investigate what happens when you put some HTML tags in the return string? Could you use this to build a more interesting page? Note that we'll use easier techniques to build HTML pages later, but I want you to get into the habit of doing the following, playing with code, experimenting, and trying out your own ideas, so that you can build your own understanding of how all the various things that we're learning work together.
\end{framed}

\paragraph{} Over the next few chapters we will look at a whole host of things we can do with Flask. However you should also rest assured that all of the tools we are learning will prove useful to you at some point in your career and will help you to become the best developers that you can be.

%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%
% CHAPTER 03
%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%


\chapter{Python Flask: Debug Mode, Errors, Routing, \& Static Files}
\label{lab3}
\paragraph{} The last two weeks have got us to the point where we can build a simple `Hello Napier' web app using Python and Python-Flask hosted within our Linux dev server environment and whose source code is pushed to our personal Github (or Bitbucket) repositories. We can now start to expand our web-app skills using Python-Flask. We'll start by looking at the debug mode which enables us to tell the Flask development server to do hot reloads of updated code whenever we save our edited python web-app file. This saves us lots of time as we begin to make lots of changes to our web-app. Additionally, we should expect to to see lots of errors. After all we are working with lots of new tools. So we shall look at Flask errors and how to deal with them. Then we will look at routing requests from web browsers to different URLs, basically how to build a tree of web addresses that each fire off a different Python function when the browser tries to access them. Finally we will look at serving up static files, like image files from the file system.

\begin{framed}
\textbf{VERY IMPORTANT} Chapters for this and subsequent weeks build directly on all of the skills learned in the first two chapter, Linux, SSH, and Vim from chapter \ref{lab1} and Python and Python Flask from \ref{lab2}.

\paragraph{} To some degree you can mix and match this and subsequent chapters and subsections to meet your needs, for example, the type of web app you want to build, but you should aim to cover all chapters by the end of the semester.
\end{framed}

\section{Flask Debug Mode}
\label{debug}
\paragraph{} Recall that our `Hello Napier' app looks like this:

\begin{lstlisting}
from flask import Flask
app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello World!"
\end{lstlisting}

\paragraph{} When we run this Python flask app using the python command in the terminal, e.g.

\begin{lstlisting}[style=DOS]
$ python3 -m flask run --host=0.0.0.0 
 * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)
 * Restarting with stat
\end{lstlisting}

\paragraph{} Python calls the run function of the app object and executes it. By default run() takes no arguments but we have used the \emph{host='0.0.0.0'} argument to tell flask to allow connections from outside of the local machine, this is what enables us to access the web-app from Windows as by default we would only be able to access the web-app from within the Linux dev server. However both the app object and the run function have a number of other features that we can use. Whilst developing a new web-app one of the most important is the debug mode which we can run by setting the Flask environment variable to development, e.g.

\begin{lstlisting}[style=DOS]
    $ export FLASK_ENV=development
\end{lstlisting}

\paragraph{} Two important features of the debug mode are

\begin{enumerate}
\item Causing the development server to automatically restarted each time we change our code, e.g. each time we save (\emph{:w $<$ENTER$>$}) our file after editing it in Vim.
\item Printing out debug information and a Python stack trace in the browser so that we can work out what went wrong.
\end{enumerate}

\paragraph{} If we try to access a route that causes a Python error then instead of this

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/flask-internal-server-error.png}
\caption{Flask internal server error}
\label{fig:flask-internal-server-error}
\end{figure}
 \paragraph{} We will get a Python stack trace displayed in the browser (and printed on the output in the terminal where you ran the web-app). Here is an example but remember that the stack trace will differ greatly depending upon the type of error and the details of what went wonge so this is merely indicative:

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/flask-stack-trace.png}
\caption{An error stack trace example}
\label{fig:flask-stack-trace}
\end{figure}


\begin{framed}
\textbf{IMPORTANT} If you ever run your web-app on a publically accessible server then you must turn debug mode off as it presents a significant security risk and can allow the execution of arbitrary code.
\end{framed}

\section{Flask Routing}
\label{routing}
\paragraph{} Routing is what enables us to build sensible URLs and addresses for the pages of our web-app. You should consider the design of the address hierarchy for your web-app, the API, to be at least as important a consideration as the design of any content of your actual web-apps pages.

\paragraph{} In flask, web addresses or URLs are called routes. To add more routes to your web-app you use the app.route decorator. You just write a new Python function then add a decorator for each one to make the function into a route. For example, in the following web-app we have 3 routes:

\begin{lstlisting}
from flask import Flask
app = Flask(__name__)

@app.route("/")
def root():
  return "The default, 'root' route"

@app.route("/hello/")
def hello():
  return "Hello Napier!!! :D"

@app.route("/goodbye/")
def goodbye():
  return "Goodbye cruel world :("

if __name__ == "__main__":
  app.run(host='0.0.0.0', debug=True)
\end{lstlisting}

\section{Flask Redirects \& Errors}
\label{errors}
\paragraph{} You can redirect a user from one URL endpoint to another quite easily by using the redirect() function, for example, if we were building an app that required a user to be logged and we detected that the user wasn't logged in then we could redirect the user to a login page instead of the page that they requested, e.g.

\begin{lstlisting}
from flask import Flask, redirect, url_for
app = Flask(__name__)

@app.route("/private")
def private():
  # Test for user logged in failed
  # so redirect to login URL
  return redirect(url_for('login'))

@app.route('/login')
def login():
  return "Now we would get username & password"

if __name__ == "__main__":
  app.run(host='0.0.0.0', debug=True)
\end{lstlisting}
\paragraph{} Note that this isn't an entire web-app, just the imports and indicative code for how a redirect could work. Obviously, to complete the scenario above we would also need code to check whether the request came from a logged in user and the login page would also need to accept and check any supplied credentials (but we will look at that type of functionality in subsequent chapters). 

\paragraph{} If we try to access a page that doesn't exist then we get a default error 404 Not Found status page like the following:

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/flask-not-found.png}
\caption{The default 404 Not Found page}
\label{fig:flask-not-found}
\end{figure}

\paragraph{} However we can also provide our own error pages that better fit in with the design of our app or tell our user how to recover from the error. For example, you could provide a link to the root page or login page instead. Providing a custom HTTP error page is straightforward. Instead of the \emph{@app.route} decrator we use the \emph{app.errorhandler} decorator and pass it the code that we want to handle. We also add the code after the return message so that the code is returned to the browser.

\begin{lstlisting}
from flask import Flask
app = Flask(__name__)

@app.route("/")
def hello():
  return "Hello Napier"

@app.errorhandler(404)
def page_not_found(error):
  return "Couldn't find the page you requested.", 404

if __name__ == "__main__":
  app.run(host='0.0.0.0', debug=True)
\end{lstlisting}

\paragraph{} Now if we visit our web-app but use an address that doesn't exist (just make something up after the \url{http://set09103.napier.ac.uk:5000/} bit) we should see something like this:

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/flask-404-text.png}
\caption{Custom 404 error page}
\label{fig:flask-404-text}
\end{figure}

\paragraph{} Obviously this is not much better than the default but it does mean that we can start to build custom errors for our web-app, and once we start to look at returning HTML pages, using templates, and adding style with CSS then custom errors really become useful.

\paragraph{} You should also be aware that there are many error codes that your web-app might conceivably respond to. Some, badly designed sites will only respond with a 404 regardless of the error that occured, but the range of error codes actually means that you can respond with appropriate information that enables your user to make an informed decision about what to do next. Try implementing some other error codes. Because it can be difficult to force these errors to occur there is a shortcut in Flask that allows us to inject a specific type of error at any point which can be useful for testing.

\begin{lstlisting}
from flask import Flask, abort
app = Flask(__name__)

@app.route("/")
def hello():
  return "Hello Napier"

@app.route('/force404')
def force404():
  abort(404)

@app.errorhandler(404)
def page_not_found(error):
  return "Couldn't find the page you requested.", 404

if __name__ == "__main__":
  app.run(host='0.0.0.0', debug=True)
\end{lstlisting}

\paragraph{} Note the line that contains ``abort(404)''. In this line the abort function is used which immediately causes an error to occur resulting in the corresponding errorhandler being called.

\section{Flask Static Files}
\label{static}
\paragraph{} Even though we have seen some techniques for generating web-apps and pages dynamically from code, it is often useful to have static files, e.g. javascript, images, and CSS, that are stored in the filesystem. This enables you to incorporate useful standard web tools like, for example, JQuery, into your web-app, so you don't have to write or generate \emph{everything} in Python. 

\paragraph{} This means that we can generate an HTML file, to return to the client, using Jinja2 templates, but that the other artefacts of a web site, such as CSS and JS files, can be stored statically and served directly to the client. If you think about it, this makes some sense. Whilst an individual page within a site might change, to reflect the data contained within that page, many aspects remain static between and across calls. For example, the style of a site doesn't usually change as you navigate through the site, instead it remains fairly static. In fact a hallmark of a good design is usually that it is consistent across all aspects that it applies to. So the CSS doesn't need to be generated on the fly. Similarly images used within a site aren't generated on the fly, icons, navigational images, or illustrative images are usually pictures that are optimised and then stored. Once stored they remain static. JS is the same, it is written and tested against design criteria, then stored as JS files, ready to be retrieved during an HTTP call. These kinds of site artefact are all static, they don't generally need to change during a call from a client so it would probably be a waste of resources to generate them. Why not just store them statically, as files in the file systems, perhaps in a specical folder whether other static files are stored, until needed?

\paragraph{} Note that this contrasts with many HTML pages themselves, particularly if the page depends upon some query from the client and might need to contain different information as a result. For example, if a page contains a table of data as a result of a database query, which in turn depends upon the parameteres of the request made by the client. The data in the table needs to be assembled based on the results of the query so the page is \emph{dynamic}. We have a different way to handle dynamic HTML using \emph{templates} which we'll see later in chapter \ref{style}.

\paragraph{} To use static files, all you have to do is to create a directory called `\emph{static}' that is a sub-directory (child) of the directory in which your web-app is located. You can them place your static files, your CSS, JS, image files, \&c., into this folder and Flask will automatically look there for them when an HTML files requests them\footnote{You can override Flask's default placement of static files into the static folder and use some other folder name if you like using Flask's configuration options.}\footnote{Remember that an HTML file requests other files, like CSS using the $<$link$>$ tag and JS using the $<$script$>$ tag}. You can, and should organise files within your static folder though. Create sub-folders to so that your static files are well organised. This is particularly important as the size of your site, and the number of files that make up your site, grows. With small to medium sites I've found that sorting all CSS files into their own `css' sub-folder, all JS files into their own `js' sub-folder, and all images into their own `img' sub-folder is sufficient to keep things organised.

\paragraph{} Usually, if you were deploying your web-app in the wild as a public web-site then you would use a static web-server to host your static files and a web-app server, such as uWSGI, to host your dynamic flask app. This is because each is optimised for serving either static or dyanamic files. A static web server takes the load of hosting and serving up the static files themselves and then delegates the dynamic pages to the appropriate web-app server. We will consider this approach later in the module\footnote{Deployment, hosting, administration, \& tuning of high-performance web sites is outside the scope of this module, and could alone form an entire module, however we will consider and discuss a range of tools and techniquess for deploying Flask web-apps that are generally applicable to most web sites.}.However, during development it is sufficient to use the \emph{static} sub-directory. 


\paragraph{} You can then retrieve any static file, for example a CSS file called \emph{style.css}, using the Flask `url\_for' function like so:

\begin{lstlisting}
    url_for('static', filename='style.css')
\end{lstlisting}

\paragraph{} This function looks for the file named `style.css' within the `static' folder and, if found, generates the public URL for that file. In essence it translates from the internal location within the server's filesystem hierarchy, which is private to the server, to a public web address. If anyone has that address then they can retrieve the file. So if we have an image in our static folder put the result of url\_for in relation to that image into the src attribute of an img tag within an html file then that html file will retrieve and display the image. Perhaps we should try that. Let's get an image file and put it in our static folder, then afterwards we'll generate an HTML file containing an image tag in a flask route and insert the URL for our static image into that image tag.

\paragraph{} For this to work we need an image file and we need to put that file into a /static/ subdirectory of our current flask app. First create the /static/ directory. Change directory to a folder with an active virtualenv and then create a static sub-folder within it, e.g.

\begin{lstlisting}[style=DOS]
    $ mkdir static 
\end{lstlisting}

\paragraph{} Now retrieve an image file. We'll use a known good image in this example, but the file could be any image file that a browser understands. This includes JPG, PNG, and GIF files amongst others. There are many methods for getting images files onto our server but we'll use the cURL tool at the command line to retrieve a remote image from the internet and make a local copy like so:

\begin{lstlisting}[style=DOS]
    $ curl -o vmask.jpg siwells.github.io/assets/images/vmask.jpg 
\end{lstlisting}

\paragraph{} Now move the image into our static sub-folder:

\begin{lstlisting}[style=DOS]
    $ mv vmask.jpg static/
\end{lstlisting}

\paragraph{} Now we have stored an image file, \emph{vmask.jpg}, in the static folder we can use flask to refer to that image within our code and generated HTML. So let's generate an img link and return it to our user for display in their browser:

\begin{lstlisting}
from flask import Flask, url_for
app = Flask(__name__)

@app.route("/")
def hello():
  return "Hello Napier"

@app.route('/static-example/img')
def static_example_img():
  start = '<img src="'
  url = url_for('static', filename='vmask.jpg')
  end = '">'
  return start+url+end, 200

if __name__ == "__main__":
  app.run(host='0.0.0.0', debug=True)
\end{lstlisting}

\paragraph{} Notice how we have used a standard HTML image (img) tag, filled in the src attibute using the output from url\_for, then concatenated the three strings together to form the string that is returned by the static\_example\_img function. I wonder what other HTML tags could be used to return information from a URL? Perhaps we could build entire web-pages this way, by just concatenating various sections of HTML to make an entire page....\footnote{You can do this, and you can return \emph{any} HTML tags this way and build up quite complex pages. However in chapter \ref{style} we will look at how we can use templates to design how our pages look using a mixture of HTML and special coding tags to dynamically build pure HTML responses.}.

\paragraph{} If you now visit your VM in your browser, e.g. \url{http://set09103.napier.ac.uk:5000/static-example/img} {replaceing set09103 with your own VM ID) you will see the relative URL for the image file. It should look something like this:

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/flask-static-img.png}
\caption{Displaying a static image using the \emph{url\_for} function}
\label{fig:flask-static-img}
\end{figure}

\paragraph{} Applying this to other types of static file follows a similar pattern. For example, to insert CSS into our returned page, use url\_for to retrieve the publicly accessible address for a CSS file in your static folder, and then insert the resulting address into the href attribute of a $<$link$>$ tag. Or for a JS file do the same but insert it into the src attribute of a $<$script$>$ tag.

%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%
% CHAPTER 04
%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%

\chapter{Python Flask: Requests \& Responses}
\label{lab04}
\paragraph{} In the last chapter we looked at how to do routing. That is how to execute a different function depending upon which URL the browser requested. This week we will look in more detail at the requests themselves. Because requests can include more than just a simple HTTP GET we shall look at how to handle different HTTP methods, such as GET, POST, PUT, \& DELETE, before looking at URL encoding of arguments to a route. The, after receiving and handling request data, we will look at the responses that we can return to the client.


\section{Requests}
\label{requests}
\paragraph{} When your browser connects to a URL it is making a {\textbf request}. In Flask, requests are Python objects that we can access and whose data we can reuse. For example, a request might carry a payload such as a document associated with a POST request and we will likely need to retrieve that payload document from the request in order to process the data and return an appropriate response.

\paragraph{} You can, for development, debugging, and educational purposes, investigate the request object by printing the request.method, request.path, and request.form attributes to retrieve data about the actual request, e.g.

\begin{lstlisting}
print (request.method, request.path, request.form)
\end{lstlisting}

\subsection{HTTP Methods}
\label{http-methods}
\paragraph{} HTTP uses various methods to move data around. The most commonly used method, and the one we have used exclusively until now is the default GET method. Look at the output from the Python Flask development server and you should see lines similar to the following:

\begin{lstlisting}[style=DOS]
10.0.2.2 - - [27/Sep/2015 18:59:51] "GET / HTTP/1.1" 200 -
10.0.2.2 - - [27/Sep/2015 18:59:58] "GET /hello HTTP/1.1" 200 -
10.0.2.2 - - [27/Sep/2015 19:00:05] "GET /goodbye HTTP/1.1" 200 -
\end{lstlisting}

\paragraph{} Notice the part of each line that says GET? This is because we have been interested only in retrieving information using the \emph{de facto} default HTTP method.
\paragraph{} HTTP specifies a range of methods for requesting web resources and these methods are oftern referred to as HTTP Verbs. By default a client usually makes GET requests and most web resources will respond to a GET request, however a resource, identified by a route, can respond differently to different verbs. So, for example, we can make a GET request to retrieve a resource or a POST request to send information to the resource. We can then write code to respond to differnt requests in different ways.

\paragraph{} As we said, a Flask route will accept GET requests by default, and Flask also supports HEAD requests automatically when GET is present, but we can also add support for other verbs to the route decorator method, e.g. to specify that a route can accept both GET and POST requests we would use the following decorator:

\begin{lstlisting}
@app.route('/account', methods=['GET', 'POST'])
\end{lstlisting}

\paragraph{} Within the method associated with that decorator we could then use an \emph{if...else} block to execute different code, e.g. 

\begin{lstlisting}
from flask import Flask, request
app = Flask(__name__)

@app.route("/")
def root():
  return "The default, 'root' route"

@app.route("/account/", methods=['GET', 'POST'])
def account():
  if request.method == 'POST':
    return "POST'ed to /account root\n"
  else:
    return "GET /account root"

if __name__ == "__main__":
  app.run(host='0.0.0.0', debug=True)
\end{lstlisting}


\paragraph{} To test this we can browse to \url{http://set09103.napier.ac.uk:5000/account} and we should see the result of GET'ting the request.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/flask-simple-posting.png}
\caption{Result from GET'ting our account/ route}
\label{fig:flask-simple-posting}
\end{figure}


\paragraph{} To test the POST call is slightly more involved for now. As we haven't implemented any HTML yet that is capable of calling this root using a POST request we need to mock one up. We can use cURL for that. The easiest way is to open a new SSH window and log into the dev server then execute cURL locally on the server. We could do the same from Windows but working with the Windows command line is a pain (and we have already invested time in learning the Linux command line so we might as well continue with that. In Linux you can now just run:

\begin{lstlisting}[style=DOS]
$ curl -i -X POST http://set09103.napier.ac.uk:5000/account/
\end{lstlisting}

\paragraph{} obviously replacing 5000 with the port that your API is running on if you've deployed elsewhere (like 80 or 8080). This will give output like this:

\begin{lstlisting}[style=DOS]
HTTP/1.0 200 OK
Content-Type: text/html; charset=utf-8
Content-Length: 24
Server: Werkzeug/0.10.4 Python/2.7.10
Date: Sun, 04 Oct 2015 12:51:12 GMT

POST'ed to /account root
$ 
\end{lstlisting}

\paragraph{} We can find out what HTTP method was used by checking the request method (as we saw in section \ref{http-methods}). Data transmitted in a POST or PUT request can then be accessed using the form attribute of the request object.

\subsection{Request \& Request Form Data}
\label{requests-objects-and-form-data}
\paragraph{} Now let's look at an example that displays a form when we connect to the URL using GET then display a different page that uses data from the form when we submit a POST request by pressing the form's button.

\begin{lstlisting}
from flask import Flask, request
app = Flask(__name__)

@app.route("/account/", methods=['POST','GET'])
def account():
  if request.method == 'POST':
    print (request.form)
    name = request.form['name']
    return "Hello %s" % name
  else:
    page ='''
    <html><body>
      <form action="" method="post" name="form">
        <label for="name">Name:</label>
        <input type="text" name="name" id="name"/>
        <input type="submit" name="submit" id="submit"/>
      </form>
      </body><html>'''

    return page
    
if __name__ == "__main__":
  app.run(host='0.0.0.0', debug=True)
\end{lstlisting}

\paragraph{} This should yield something similar to the following when we visit \url{http://set09103.napier.ac.uk:5000/account/} in the browser:

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/flask-form.png}
\caption{Our basic HTML form when GET'ting the account route}
\label{fig:flask-form}
\end{figure}

\paragraph{} It is worth noting how we have used a Python multiline string, which starts with ''' and ends with ''' to build up an html page completely within out Python function. When we enter data into the input box the click the button we should get different page displayed as a result of the form POST'ing:

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/flask-form-data.png}
\caption{Page displayed after POST'ing the form}
\label{fig:flask-form-data}
\end{figure}



\paragraph{} We will return to using POST, PUT, and other verbs in chapter \ref{lab08} when we look at designing and building APIs that consume and return JSON and XML documents.


\subsection{URL Variables}
\label{url-variables}
\paragraph{} We can also construct URLs that have variables within them. For example, if we wanted a URL route that enabled us to retrieve a user's details by name then we might want a URL of the following pattern \emph{/account/$<$username$>$} where $<$username$>$ is replaced by an actual name. We can achieve this using URL variables, e.g.

\begin{lstlisting}
from flask import Flask
app = Flask(__name__)

@app.route("/hello/<name>")
def hello(name):
  return "Hello %s" % name

if __name__ == "__main__":
  app.run(host='0.0.0.0', debug=True)
\end{lstlisting}

\paragraph{} We can now call the url, e.g. using the name 'simon' in the following \url{http://set09103.napier.ac.uk:5000/hello/simon} and we would get the following output:

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/flask-url-variables.png}
\caption{Using URL variables}
\label{fig:flask-url-variables}
\end{figure}

\paragraph{} By default URL variable are strings but we ca also specify other variable types such as int and floats, for example,

\begin{lstlisting}
from flask import Flask
app = Flask(__name__)

@app.route("/add/<int:first>/<int:second>")
def add(first, second):
  return str(first+second)

if __name__ == "__main__":
  app.run(host='0.0.0.0', debug=True)
\end{lstlisting}

\paragraph{} With the following result:

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/flask-url-variables-ints.png}
\caption{Output from using specific URL variable types}
\label{fig:flask-url-variables-ints}
\end{figure}



\subsection{URL Parameters}
\label{url-parameters}
\paragraph{} Rather than construct and send a document to the server or use a POST'ed form, we will often want to send small amount of non-secure data to the server encoded within the URL. This is straightforward in Flask. 

\paragraph{} Parameters can be encoded in the URL when a client make a request. Flask can retrieve these parameters and use them by using the args attribute of the request object, e.g. for a URL that incorporates \emph{?key=value} parameters similar to the following:

\begin{lstlisting}[style=DOS]
/update?colour=green
\end{lstlisting}

\paragraph{} Then we can access the corresponding keys like so:

\begin{lstlisting}
searchterm = request.args.get('key', '')
\end{lstlisting}

\paragraph{} The value for key is then retrieved from the URL and stored in `searchterm'. If no such key is supplied then the value in the second pair of quotes is used as a default instead but in the example above we have just used an empty string.

\paragraph{} Now let's look at a simple example, which you can use to send your name as a URL encoded parameter, and have a route accept and process it we can do the following:

\begin{lstlisting}
from flask import Flask, request
app = Flask(__name__)

@app.route("/hello/")
def hello():
  name = request.args.get('name', '')
  if name == '':
    return "no param supplied"
  else:
    return "Hello %s" % name

if __name__ == "__main__":
  app.run(host='0.0.0.0', debug=True)
\end{lstlisting}

\paragraph{} When we run this without supplying a parameter, e.g \url{http://set09103.napier.ac.uk:5000/hello/} then we get this output:

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/flask-url-param-empty.png}
\caption{Output with no URL parameter}
\label{fig:flask-url-param-empty}
\end{figure}

\paragraph{} When we supply a parameter, e.g. \url{http://set09103.napier.ac.uk:5000/hello/?name=simon} then we get this output:

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/flask-url-param-name.png}
\caption{Output when supplying a ?name=simon URL parameter}
\label{fig:flask-url-param-name}
\end{figure}


\subsection{Uploading Files}
\label{file-uploading}
\paragraph{} One final thing to consider that is related to client requests, is the matter of file uploading. We will occasionally want to enable our users to upload materials to our site and we can do this by ensuring that two things occur. The form which POSTs the data must cause the browser to transmit the file that we want to upload and our method that the route executes must also access the request and do something with the transmitted file. Otherwise the file will sit by default either in memory or in temptorary storage rather then being saved for later reuse. In the following I used a PNG image file that I had available as the uploaded file:

\begin{lstlisting}
from flask import Flask, request
app = Flask(__name__)

@app.route("/account/", methods=['POST','GET'])
def account():
  if request.method == 'POST':
    f = request.files['datafile']
    f.save('static/uploads/upload.png')
    return "File Uploaded"
  else:
    page='''
    <html>
    <body>
    <form action="" method="post" name="form" enctype="multipart/form-data">
      <input type="file" name="datafile" />
      <input type="submit" name="submit" id="submit"/>
    </form>
    </body>
    </html>
    '''
    return page, 200

if __name__ == "__main__":
  app.run(host='0.0.0.0', debug=True)
\end{lstlisting}

\paragraph{} Notice that the file is being saved in a sub-directory of static called `uploads'. This makes it easier to access the uploaded file and use it within our app. Look in `static/uploads' for the new file. Perhaps you could combine this file upload facility with the image display example that we saw in section \ref{static}. For example:

\begin{lstlisting}
from flask import Flask, request, url_for
app = Flask(__name__)

@app.route("/display/")
def display():
  return '<img src="'+url_for('static', filename='uploads/file.png')+'"/>'

@app.route("/upload/", methods=['POST','GET'])
def account():
  if request.method == 'POST':
    f = request.files['datafile']
    f.save('static/uploads/file.png')
    return "File Uploaded"
  else:
    page='''
    <html>
    <body>
    <form action="" method="post" name="form" enctype="multipart/form-data">
      <input type="file" name="datafile" />
      <input type="submit" name="submit" id="submit"/>
    </form>
    </body>
    </html>
    '''
    return page, 200

if __name__ == "__main__":
  app.run(host='0.0.0.0', debug=True)
\end{lstlisting}

\paragraph{} Of interest here is that when we access the display method repeatedly you should see in the output from the Flask development server something similar to this:

\begin{lstlisting}[style=DOS]
10.0.2.2 - - [05/Oct/2015 17:29:14] "GET /display/ HTTP/1.1" 200 -
10.0.2.2 - - [05/Oct/2015 17:29:15] "GET /static/uploads/file.png HTTP/1.1" 304
\end{lstlisting}

\paragraph{} In this case we get the 304 because the image file hasn't changed (another reason we store it in our static repository. However, a final note on file uploads and static files. In a real-world deployment we usually wouldn't serve static files directly from within Flask as other HTTP servers like NGinX can do this much more reliably and efficiently. However for development and educational purposes using the Flask static directory is an acceptable approach.


\section{Responses}
\label{responses}
\paragraph{} When we return a value from a function it is automatically turned into a valid HTML response object. If the value is a String then it is used as the body of the response which is why when we just do something like this:

\begin{lstlisting}
from flask import Flask
app = Flask(__name__)

@app.route("/")
def root():
    return "Hello Napier"

if __name__ == "__main__":
  app.run(host='0.0.0.0', debug=True)
\end{lstlisting}

\paragraph{} then our browser displays the String that the function returned. A 200/OK HTTP status code is also returned by default and the mimetype is set to text/html. We will return to this topic later when we look at API building and consider setting and returning custom headers.


'\section{Inspecting Requests \& Responses}
\label{inspecting-requests-and-responses}
\paragraph{} In the lectures we've been considering HTTP as a protocol and have focussed on the things that makes HTTP communication into a language for interactions between the HTTP client and the HTTP server. This involves not only requests and responses but also supplementary aspects of the communication such as HTTP verbs and status codes. 

\paragraph{} In order to really get a grip on this it can be useful to see what is actually being sent in a real request, and what is being returned in a real response. We're also now at the point when we can manipulate all of those aspcets of HTTP using FLask, so again, it can be usful to see what is actually happening in terms of changes to our requests and responses. We've seen earlier how we can use cURL to acces and test our API, by crafting requests, but we can also use it to inspect both the requests and the response.

\paragraph{} By using the -v argument of cURL, where v stands for ``verbose'', we can get cURL to print more information about what it is sending and receiving. Let's try that now.

\begin{lstlisting}[style=DOS]
$ curl -v http://0.0.0.0:5000/
*   Trying 0.0.0.0...
* TCP_NODELAY set
* Connected to 0.0.0.0 (127.0.0.1) port 5000 (#0)
> GET / HTTP/1.1
> Host: 0.0.0.0:5000
> User-Agent: curl/7.64.1
> Accept: */*
> 
* HTTP 1.0, assume close after body
< HTTP/1.0 200 OK
< Content-Type: text/html; charset=utf-8
< Content-Length: 12
< Server: Werkzeug/2.0.1 Python/3.8.2
< Date: Mon, 27 Sep 2021 12:42:12 GMT
< 
* Closing connection 0
Hello World!~
$ 
\end{lstlisting}

\paragraph{} In this example we've used cURL to access the default route from our `hello world' Flask app from Section \ref{hello-napier} which is running on localhost port 5000 (\url{http://0.0.0.0.:5000}). There are two parts to our output from cURL, the first is the request that is being sent, and the second is the response that we get. Notice how we get a lot more information by doing this than if we just accessed \url{http://0.0.0.0.:5000} via our browser. If we did that then all we'd see is ``Hello World!'' in our browser window. This way we get to see information about the HTTP version, the content encoding, the server software\footnote{Werkzeug is a library that underpins Flask and is one of the other modules installed when you pip install Flask.}.

\paragraph{} Note that we can also use the developer tools built into Chrome to inspect the request and response headers for any given site we navigate to. To do this navigate to the page you want to inspect the request for, then open the developer tools and select the `Network' tab and refresh the page. Now select the URL in the list on the left hand side of the page then the `Headers' tab on the right hand side to have the headers displayed for you. This separates the headers into the request headers and the response headers as well as providing some general information about the communication as illustrated in Figure \ref{fig:chrome-header-inspection}.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/chrome-header-inspection}
\caption{Inspecting request and response headers using the Chrome Developer Tools}
\label{fig:chrome-header-inspection}
\end{figure}




%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%
% CHAPTER 05
%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%
\chapter{HTML Templates using Jinja2}
\label{style}
\paragraph{} Storing and writing our HTML code in Python as we have done in previous chapters is not a lot of fun. It is finicky and error-prone and doesn't give us much scope for doing interesting things like generating HTML pages on the fly. Luckily there is a solution for that. Using \emph{templates} we can describe the basic layout of a page and sign-post those elements that Python can fill in with actual data. Python uses an external templating engine, called Jinja2\footnote{\url{https://palletsprojects.com/p/jinja/}} which is already installed on the Linux dev server alongside Python and Python-Flask.

\paragraph{} Jinja2 is a fully-fledged Python templating engine and is not dependent upon Flask. So if you were writing another app at some point in your career that outputs HTML pages then Jinja2 is a good option. For the moment though we shall use it exclusively with Flask.


\subsection{Templates \& Tags}
\label{templates-tags}
\paragraph{} The process is simple. We supply HTML templates, in a template folder, then, in our functions we tell Flask which template to render and return to the client using the render\_template function. So we have a couple of setup tasks to do. First, create a templates folder in the same folder as your Python Flask app, e.g.

\begin{lstlisting}[style=DOS]
$ mkdir templates
\end{lstlisting}

\paragraph{} Now create a simple HTML template, called hello.html inside the templates folder, e.g.
\begin{lstlisting}[style=DOS]
$ touch templates/hello.html
\end{lstlisting}

\paragraph{} Now open hello.html in Vim for editing, e.g.
\begin{lstlisting}[style=DOS]
$ vim templates/hello.html
\end{lstlisting}

\paragraph{} Now we can put some HTML and Jinja2 tags into our template so that we can use the template from within Flask:


\begin{lstlisting}
<!doctype html>
    <h1>Hello {{ user.name }}!</h1>
</html>
\end{lstlisting}

\paragraph{} What we have just done is create a template that is a mix of Jinja2 tags, indicated by the \{\{, and \}\} tags, and HTML tags, indicated by the $<$ and $>$ tags that we are already used to. The HTML tags are rendered as you would expect regular HTML to be treated, but we also have a variable placeholder for user.name which means that we can supply a variable to replace the name placeholder with. Let's use our template now in a quick Flask app:

\begin{lstlisting}
from flask import Flask, render_template
app = Flask(__name__)

@app.route('/hello/<name>')
def hello(name=None):
    user = {'name': name}
    return render_template('hello.html', user=user)

if __name__ == "__main__":
    app.run(host='0.0.0.0', debug=True)
\end{lstlisting}

\paragraph{} Now if we call \url{http://set09103.napier.ac.uk:5000/hello/simon} then we should instead see this rendered template:

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/flask_template_basic}
\caption{Rendered HTML with a very simple template \& a single parameter}
\label{fig:flask_template_basic}
\end{figure}


\subsection{Templates with Conditional Arguments}
\label{templates-conditional}
\paragraph{} We can also use Jinja2 templates to perform conditional behaviours, for example, rendering our HTML differently depending upon the data that is passed in. This lets us do things like personalise a page if we have a person's name or else provide a default generic page if we don't. Let's look at the template, conditional.html, for such a scenario (you can either create this now or get the file from the repo). Conditional.html has the following content:

\begin{lstlisting}
<!doctype html>
{% if name %}
    <h1>Hello {{ name }}!</h1>
{% else %}
    <h1>Hello from Napier!</h1>
{% endif %}
</html>
\end{lstlisting}

\paragraph{} The Jinja2 tags cause conditional behaviour to occur; in this case they form an if...else clause, just like we have seen in many other procedural languages like Java, C, or even Python. Let's use our template now in a quick Flask app:

\begin{lstlisting}
from flask import Flask, render_template
app = Flask(__name__)

@app.route('/hello/')
@app.route('/hello/<name>')
def hello(name=None):
    return render_template('conditional.html', name=name)

if __name__ == "__main__":
    app.run(host='0.0.0.0', debug=True)
\end{lstlisting}

\paragraph{} There are a couple of things to notice here:
\begin{enumerate}
\item Notice how we have stacked up two @app.route calls - yes, a single function can have multiple routes defined for it, any of which can cause the function to be executed.
\item We have also used a URL variable in one of the route so that we can supply a name. Notice that the hello function takes a name argument and that it is set to `name=None' - this just means that we have set a default value for name in case the route without the URL variable is used.
\item In the hello function we use the render\_template function from the Flask library which basically looks in the templates directory for a template whose name matched the one that we have supplied, `hello\_template.html'. The function then \emph{completes} the template, i.e. exchanging the Jinja2 tags for valid HTML tags, according to the arguments that we provide. In this case we provide the name=name argument, which will either have the value of None or else will be equal to the name that we supplied when we called the route. This argument is used to determine which path of the if...else clause to follow in the template and what value to replace any template variables with.
\end{enumerate}

\paragraph{} If we now call \url{http://set09103.napier.ac.uk:5000/hello} then we should see the following:

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/flask-template-conditional-no-arg}
\caption{Conditional template rendering without URL arguments}
\label{fig:flask-template-conditional-no-arg}
\end{figure}

\paragraph{} But if we call \url{http://set09103.napier.ac.uk:5000/hello/simon} then we should instead see this rendered template:

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/flask-template-conditional-arg}
\caption{Conditional template rendering with a single URL argument}
\label{fig:flask-template-conditional-arg}
\end{figure}


\subsection{Templates \& Collections}
\label{templates-collections}
\paragraph{} A very useful technique for generating HTML is to build a list or dictionary in Python then pass that collection into the template and cause the template to iterate over the elements of the collection. Let's look at a simple example now; here is a simple template that incorporates a Jinja2 looping construct:

\begin{lstlisting}
<!doctype html>
<body>
  <ul>
    {% for name in names %}
     <li>{{ name }}</li>
    {% endfor %}
  </ul>
</body>
</html>
\end{lstlisting}

\paragraph{} We can now use this template in a Python Flask function as illustrated here:

\begin{lstlisting}
from flask import Flask, render_template
app = Flask(__name__)

@app.route('/users/')
def users():
  names = ['simon', 'thomas', 'lee', 'jamie', 'sylvester']
  return render_template('loops.html', names=names)

if __name__ == "__main__":
  app.run(host='0.0.0.0', debug=True)
\end{lstlisting}

\paragraph{} Notice that we merely constructed a Python list, a simple data structure, that is a list of names. We then passed that list into the render\_template function for processing by the templating engine. If we now visit \url{http://set09103.napier.ac.uk:5000/users/} we should see that our Python list has been rendered as an unordered HTML list.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/flask-templates-loops}
\caption{Looping over data in within a template to generate HTML}
\label{fig:flask-templates-loops}
\end{figure}

\paragraph{} By using simple looping techniques and carefully considering the data that we pass from our Python function into a template, we can generate complex and dynamic HTML layouts.


\subsection{Template Inheritance}
\label{template-inheritance}
\paragraph{} Because multiple templates can also be used to define headers, footers, and any other sub-part of individual pages in your app this means you can easily change and manage the look and feel of your apps. This approach is called \emph{Template Inheritance} and means that you can, for example, define a header or menu-bar just once, e.g. in a template called menu.html and then include that template in every other pages which you want to display the menu. If you ever wish to add or remove a menu item then you only have to make a single edit to the menu template. Nice isn't it? This follows an established software design pattern of attempting to separate application logic separate from the presentation, markup or layout of data. Although you might ask, ``what about the logic in the template?'', you are correct, there is a little bit of overlap where logic directly concerns rendering the templates but for the most part, done correctly, all of the computation of your web-app should be done in Flask and the rendering into HTML is done separately in Jinja2. This is a pretty good balance I think.

\paragraph{} To demonstrate template inheritance we will first define a base template, then two templates that inherit from it. We will then create some routes that render the templates. So let's start with our base template:

\begin{lstlisting}
<html>
<head>
    <title>Template Inheritance Example</title>
</head>
<body>
    <h1>Title stored in the base template</h1>
    <h2>With a subtitle</h2>

    {% block content %} {% endblock %}

</body>
</html>
\end{lstlisting}

\paragraph{} For the most part this is just a normal HTML file except that it incorporates some Jinja2 tags to set out blocks that we have called `content'. It is these blocks that are replaced within the templates that inherit from the base template. We can now inherit this base template and reuse the common elements as follows:

\begin{lstlisting}
{% extends "base.html" %}
{% block content %}
  <p>First example template. It contains some stuff</p>
{% endblock %}}
\end{lstlisting}

\paragraph{} The main point to be aware of is that the \emph{derived} template specifies that it inherits from the base template. Just to demonstrate that this works for different templates, let's create a second template that also inherits from the base template but which contains different content to the last pone.

\begin{lstlisting}
{% extends "base.html" %}
{% block content %}
  <p>A second example. It's different to the other one.</p>
{% endblock %}}
\end{lstlisting}

\paragraph{} We can make a Flask file which has routes that render our templates.

\begin{lstlisting}
from flask import Flask, render_template
app = Flask(__name__)

@app.route('/inherits/')
def inherits():
    return render_template('base.html')

@app.route('/inherits/one/')
def inherits_one():
    return render_template('inherits1.html')

@app.route('/inherits/two/')
def inherits_two():
    return render_template('inherits2.html')

if __name__ == ("__main__"):
    app.run(host='0.0.0.0', debug=True)
\end{lstlisting}

\paragraph{} Here we have three different routes. The first one `/inherits/' merely shows what the base template looks like when it is rendered without additional templates that inherit from it. In the other two routes `/inherits/one/' and `/inherits/two/' we see how the base template is modified when it is extended by two different inheriting templates. Using this approach we can build a hierarchy of page templates whilst minimising the amount of reptition by ensuring that each element that will be repeated between HTML pages is inherited from a parent template.

\paragraph{} This is the output from our first template that inherits from base.html. It displays some content that comes from inherits1.html and some headings that are inherited from the base template.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/flask-template-inheritance-1}
\caption{The first page that inherits from our base template}
\label{fig:flask-template-inheritance-1}
\end{figure}

\paragraph{} Our second page that inherits from the base template. Notice that the same headers are displayed as on the other page. However we have different content as defined by the inherits2.html template.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/flask-template-inheritance-2}
\caption{The second page that inherits from our base template}
\label{fig:flask-template-inheritance-2}
\end{figure}

\paragraph{} Just for completion, let's also look at what the base template looks like when rendered. We don't \emph{have} to provide a route to it, but if we do then we can view the HTML that it generates:

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{images/flask-template-inheritance-base}
\caption{The rendered base template}
\label{fig:flask-template-inheritance-base}
\end{figure}

\paragraph{} You can and should use templates to describe all of the HTML pages that you want your web-apps to use. This approach is a consistent and very powerful method for generating HTML and managing the look of your web-apps.


%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%
% CHAPTER 06
%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%
\chapter{Flask: Configs, Sessions, Message Flashing, Logging, \& Testing}
\label{lab06}
\paragraph{} 

\section{Configuration \& Config Files}
\label{configs}
\paragraph{} Quite often we need to do external configuration of our Flask app, for example, if we are using external tools, like Babel, to control translations into different languages, if we need to specify an encryption key for setting up secure sessions, or a password for accessing an external mail server. We can achieve this by using configuration files, external text files that Flask can read at start up and which provide data to Flask about the environment it is running in.

\paragraph{} Create a sub-directory called `etc' just like you did for the static and templats directories. Your config files will live here. Now create a new text file in the etc directory called `defaults.cfg', this will be the default file that your flask app reads in at start up. We can now use that file to store some configuration data. Let's start by moving our debug and host settings into the config file instead of setting them in code, e.g. Add the following to your defaults.cfg:

\begin{lstlisting}
[config]
debug =  True
ip_address = 0.0.0.0
port = 5000
url = http://127.0.0.1:5000
\end{lstlisting}

\paragraph{} Our config file can be used to store whichever configuration values we decide we want to support in a flask app. For illustration purposes I have used the debug flag and IP, URL, and port numbers settings. We can now create a Flask app that uses those values, for example,

\begin{lstlisting}
import configparser
from flask import Flask

app = Flask(__name__)

def init(app):
    config = configparser.ConfigParser()
    try:
        config_location = "etc/test.cfg"
        config.read(config_location)

        app.config['DEBUG'] = config.get("config", "debug")
        app.config['ip_address'] = config.get("config", "ip_address")
        app.config['port'] = config.get("config", "port")
        app.config["url"] = config.get("config", "url")
    except:
        print("Couldn't read configs from: ", config_location)

init(app)

@app.route('/')
def root():
    return "Hello from the config testing app"

@app.route('/config/')
def config():
    s = []
    s.append('debug: '+str(app.config['DEBUG']))
    s.append('port: '+str(app.config['port']))
    s.append('url: '+str(app.config['url']))
    s.append('ip_address: '+str(app.config['ip_address']))
    return ', '.join(s)

if __name__ == "__main__":
    init(app)
    app.run(
        host = app.config['ip_address'],
        port = int(app.config['port']))
\end{lstlisting}

\paragraph{}  Notice how we are `getting' the value for each key from the config file then storing those values in the app.config object. 

\section{Sessions}
\label{sessions}
\paragraph{} Sessions are a way to manage user data between requests by storing small amounts of data within a cookie. Cookies are small data files that are stored in the users browser and are suitable for small amounts of, ideally non-private, data. Sessions rely on cookies that are cryptographically secured by Flask using a secret key to ensure that the content of the cookies hasn't been altered by any process other than the Flask app that created it. However, the content of a cookie can easily be read by the client or whilst it is transmitted between the client and server during a request\footnote{Unless the communication has been secured with HTTP but that is another topic}.

\paragraph{} Flask provides an interface for using `secured cookies' or \emph{sessions} rom our Python code and we can consider a session to be a small data store for keys and value, a form of dictionay. As a result we can set data into a session, query that data, and remove that data, 

\paragraph{} To add a key value pair we merely treat the session object as a Python dictionary\footnote{If you are unsure about Python dictionaries or `dicts' then you should do some background reading on this topic in the Python language documentation}, e.g.
\begin{lstlisting}
# Set key=value, name=simon into a session
session['name'] = simon
\end{lstlisting}

\paragraph{} You can then retrieve the value set for name in the session but because this key might not exist in the session we need to wrap everything in a try-except structure to catch the KeyError that might be raised\footnote{Again, if you are unsure about Python errors \& try-execept then you should do background reading on this}.
\begin{lstlisting}
try:
    if(session['name']):
        return str(session['name'])
except KeyError:
    pass
\end{lstlisting}

\paragraph{} The only other thing that we might need to do is to remove a specified key and it's associated value from the session. We do this using the pop function, e.g.
\begin{lstlisting}
session.pop('name', None)
\end{lstlisting}

\paragraph{} We can then put it all together into a single demonstration web-app like so.

\begin{lstlisting}
from flask import Flask, session

app = Flask(__name__)
app.secret_key = 'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT'

@app.route('/')
def index():
    return "Root route for the sessions example"

@app.route('/session/write/<name>/')
def write(name=None):
    session['name'] = name
    return "Wrote %s into 'name' key of session" % name

@app.route('/session/read/')
def read():
    try:
      if(session['name']):
          return str(session['name'])
    except KeyError:
      pass
    return "No session variable set for 'name' key"

@app.route('/session/remove/')
def remove():
    session.pop('name', None)
    return "Removed key 'name' from session"

if __name__ == "__main__":
  app.run(host='0.0.0.0', debug=True)
\end{lstlisting}

\paragraph{} Notice the `app.secret\_key' line. This is our secret key that is used to secure our session cookie so should really be stored securely, either in a config file or typed in by hand at startup, but never put in the code repository. However for demonstration purposes this is sufficient for now. The key above is sufficient for the lab work but you would generate a unique key for any real deployment and would keep it secret. You can generate a key easily using Python. Start the Python interpreter and use the os.urandom function to generate a new key that you can then copy and paste into your Flask app, e.g.

\begin{lstlisting}
$ Python
...
>>> import os
>>> os.urandom(24)
'\xfd{H\xe5<\x95\xf9\xe3\x96.5\xd1\x01O<!\xd5\xa2\xa0\x9fR"\xa1\xa8'
\end{lstlisting}


\section{Message Flashing}
\label{message-flashing}
\paragraph{} User feedback is an important consideration when trying to design a good user experience (UX). Message flashing is just one aspect of UX that Flask provides to enable easy user feedback. The scenario is quite simple, when the user does something on one page, which causes another page to be rendered and displayed, then information, a message, can be transmitted from the first page to the second, and displayed, e.g. flashed, to the user. This means that, used with the correct combinations of responses, users can interact with your web app and get feedback about the outcome of actions. A simple example will illustrate this; if you have a sign-up page for new users on which the user enters information then presses a ``join'' button you can use message flashing to provide a personalised message to the user on the next page that is displayed. For example, after pressing ``join'' either the sign up page will be redisplayed, because the supplied information is insufficient, or else the login page will be displayed. A flashed message could be displayed in either case, on the sign-up page to indicate what needs to be fixed, or on the log in page indicating that a new account was created and that the user is welcome to log in. What is essentially happening is that a message is recorded at the end of the first request, which is then accessed \emph{only} on the very next request.

\paragraph{} Message flashing sounds quite complex and does have a few moving parts, but is really very simple once you have used it once to twice. It is best shown via example, so let's get started with one

\begin{lstlisting}
from flask import Flask, flash, redirect, request, url_for, render_template

app = Flask(__name__)
app.secret_key = 'supersecret'

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/login/')
@app.route('/login/<message>')
def login(message=None):
    if (message != None):
        flash(message)
    else:
        flash(u'A default message')
    return redirect(url_for('index'))

if __name__ == "__main__":
    app.run(host='0.0.0.0', debug=True)
\end{lstlisting}
\paragraph{} Here, we have added a flashed message in one route, using the flash() function of Flask then we use the get\_flashed\_messages() method in our template to retrieve the flashed message and display it, e.g.

\begin{lstlisting}
<html>
<body>
{% with messages = get_flashed_messages() %}
  {% if messages %}
    <ul>
    {% for message in messages %}
      <li>{{ message | safe }}</li>
    {% endfor %}
    </ul>
  {% endif %}
{% endwith %}
</body>
</html>
\end{lstlisting}

\paragraph{} All that we have done here is add a flashed messagein the `/login/$<$message$>$' route then to display the flashed message when we visit the `/' page. Subsequent visits to the `/' page will not repeat the flashed message, unless of course, we visit the `login/$<$message$>$' page again

\section{Logging}
\label{logging}
\paragraph{} We can set our Flask app up to record interesting happenings into a text file so that we have a log to inspect if something bad occurs. This is actually a feature of the Python language rather than a Flask feature, but is an important part of building a real world app. First we need to make some additions to our config file, named `logging.cfg' and stored in the  `etc' folder:

\begin{lstlisting}
[config]
debug =  True
ip_address = 0.0.0.0
port = 5000
url = http://127.0.0.1:5000
[logging]
name = loggingapp.log
location = var/
level = DEBUG
\end{lstlisting}
\paragraph{} Notice the logging section towards the end which defines the name of the log file `loggingapp.log' the location, our var/ directory that we just created, and the default log level, the granularity of the logging events to record. 
\paragraph{} We now need to set up our envionrment to match the config file. We need a subdirectory called `var' which is at the same level as our `etc', `static' and `templates' directories. We now need to create an empty file in `var' which has the same name as the log file. This directory will be the location that our new log files will write to. We can do this with touch, e.g.

\begin{lstlisting}[style=DOS]
    $ mkdir var
    $ touch var/loggingapp.log
\end{lstlisting}

\paragraph{} Having set everything up all the configuration details and the basic environment we now need to make use of that set up within our python app. Create a new file called `loggingapp.py' and enter the following code:
\begin{lstlisting}
import ConfigParser
import logging

from logging.handlers import RotatingFileHandler
from flask import Flask, url_for

app = Flask(__name__)

@app.route('/')
def root():
        this_route = url_for('.root')
        app.logger.info("Logging a test message from "+this_route)
        return "Hello Napier from the configuration testing app (Now with added logging)" 

def init(app):
    config = ConfigParser.ConfigParser()
    try:
        config_location = "etc/logging.cfg"
        config.read(config_location)
        
        app.config['DEBUG'] = config.get("config", "debug")
        app.config['ip_address'] = config.get("config", "ip_address")
        app.config['port'] = config.get("config", "port")
        app.config['url'] = config.get("config", "url")

        app.config['log_file'] = config.get("logging", "name")
        app.config['log_location'] = config.get("logging", "location")
        app.config['log_level'] = config.get("logging", "level")
    except:
        print("Could not read configs from: ", config_location)


def logs(app):
    log_pathname = app.config['log_location'] + app.config['log_file']
    file_handler = RotatingFileHandler(log_pathname, maxBytes=1024* 1024 * 10 , backupCount=1024)
    file_handler.setLevel( app.config['log_level'] )
    formatter = logging.Formatter("%(levelname)s | %(asctime)s |  %(module)s | %(funcName)s | %(message)s")
    file_handler.setFormatter(formatter)
    app.logger.setLevel( app.config['log_level'] )
    app.logger.addHandler(file_handler)

init(app)
logs(app)

if __name__ == '__main__':
    init(app)
    logs(app)
    app.run(
        host=app.config['ip_address'], 
        port=int(app.config['port']))
\end{lstlisting}
\paragraph{} The init function is very similar to the one we used earlier in the config example but is now extended to also configure event logging. There are many parameters to fine tune how data is logged so if you want to make changes then you will have to dig into the Python logging documentation but for now, just accept the defaults as they produce files that cope well with lots of data, are easy to read, and which can be automatically processed. All we have had to do to use the logger is to initialise the logging system by calling our configuration modules logs() function. From then on we can actually log messages using the app.logger.warn() and passing in a String. NB. There are also other logging levels such as debug or error that we can use to distinguish the importance of different messages in the logs. Investigate the Python logging documentation to find out more. 

\paragraph{} Now, if everything is set up correctly, then every time we visit \url{http://set09103.napier.ac.uk:5000/} a new log file should be added to var/loggingapp.log and we can use an extra PuTTY window to ``tail'' the log so that we see each new log line appear in realtime. Tailing a log just means to show the last entries in the file and using the `-f' argument to the tail command causes it to follow the log, meaning that each new line is displayed in the terminal like so:

\begin{lstlisting}[style=DOS]
$ tail -f var/loggingapp.log 
INFO | 2015-10-13 17:44:37,368 |  logs | root | Logging a test message from /
INFO | 2015-10-13 17:44:45,104 |  logs | root | Logging a test message from /
INFO | 2015-10-13 17:44:46,325 |  logs | root | Logging a test message from /
^C
$ 
\end{lstlisting}

\paragraph{} From this we can see that there were three log messages displayed and that the output is arranged into columns. Getting the output nice and neat like this is the main reason we had to write so much code in our python app and config file, but it is really worth it when you are trying to track down a problem.

\paragraph{} It is a good idea to log anything that you think that you might want to have a record of and that you might need to look up in order to bug fix. Unfortunately though there are no rules for what to log and what not to log. Obviously you could log \emph{everything} but this would possibly waste disk space, but not logging enough might mean that you don't have sufficient logs to help you fix problems. However, with experimentation and experience you will develop skills in gauging the right amount of and type of data to log.

\section{Testing}
\label{testing}
\paragraph{} We can unit test our Python app, to ensure that everything is working correctly. We do this by running a test harness which sets up our Flask app then compares expected outputs to actual outputs, for example, for the following simple web-app (testing.py):

\begin{lstlisting}
from flask import Flask
app = Flask(__name__)

@app.route('/')
def root():
  return "HELLO NAPIER", 200

if __name__ == "__main__":
  app.run(host='0.0.0.0',debug=True)
\end{lstlisting}

\paragraph{} We can write tests that compare the response returned by a call to the `/' route against what we would expect. For example, is the content correct, is the content type set corretly, is the status value set correctly. Let's see some of these tests now from the testing\_test.py file. Notice that testing\_test.py imports our source file (testing) as well as the unittest library:

\begin{lstlisting}
import unittest
import testing

class TestingTest(unittest.TestCase):
  def test_root(self):
    self.app = testing.app.test_client()
    out = self.app.get('/')
    assert '200 OK' in out.status
    assert 'charset=utf-8' in out.content_type
    assert 'text/html' in out.content_type

if __name__ == "__main__":
  unittest.main()
\end{lstlisting}

\paragraph{} We have create a class for the test and asserted that the response contents match some of our expectations, e.g. that the response status is `200 OK'. Notice in line 2 that we have also imported our flask app source file so that it is accessible from this test script. To use this we just run it in the shell, e.g.

\begin{lstlisting}[style=DOS]
$ python3 testing_test.py 
.
----------------------------------------------------------------------
Ran 1 test in 0.476s

OK
\end{lstlisting}
\paragraph{} We can easily test what would happen if a test was failed by setting things up that way, let's return 404 from our root function, e.g.

\begin{lstlisting}
@app.route('/')
def root():
  return "HELLO NAPIER", 404
\end{lstlisting}

\paragraph{} Now the output from our test suite shoudl be similar to the following:

\begin{lstlisting}[style=DOS]
$ python3 testing_test.py 
F
======================================================================
FAIL: test_root (__main__.TestingTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "testing_test.py", line 9, in test_root
    assert '200 OK' in out.status
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.416s

FAILED (failures=1)
\end{lstlisting}

\paragraph{} We can write as many tests as we need to to ensure that our web-app, or any Python app, runs the way that we expect it to. We do this by writing a new class in our testing script, called a \emph{test harness}, for each test that we want to run. The unit testing framework will then discover each test class and run them, then output the results so that you know, after each edit of your code, whether you accidentally broke anything or, more importantly, changed the behaviour of code that worked previously. Testing is very important and unit testing is just one tool that we have to help us with working with larger bodies of source code. As a code base gets bigger it can sometimes be difficult to tell with a given change has subtly altered the behaviour of something else. Unit testing gives us more confidence that we haven't done so.


%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%
% CHAPTER 07
%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%

\chapter{Using Bootstrap to Add Style}
\label{lab07}
\paragraph{} We have concentrated so far on building well designed web apps that include useful features from Flask that enable us to test and configure our apps. However, we haven't spent a lot of time on making things look nice. The most we have done is use templates, in section \ref{style}, to scaffold the consistent generation of HTML for our users to read. We have also used static files, which we can use for things like Javascript, Cascading Style Sheets (CSS), icons and images, back in Section \ref{static}. We can further exploit the `/static/' directory to give us an easy way to add some style to our flask app as this is the correct place to store all of those elements that would be made to make our pages look nice. We should recognise however that this module is not a \emph{web design} module, so we shall not spend time concentrating on the design of beautiful web sites, but we shall take a short cut to get a decent and consistent basic design that provide basic framework which can be further modified to produce a beautiful app.

\paragraph{} Bootstrap is a set of CSS files and supporting Javascript that make it straightforward to add a basic style, with a selection of different layouts, to your web-app. Originally, Bootstrap was developed by Twitter as an easy way to \emph{bootstrap} from plain HTML to a site with a basic overall design which can be enhanced and which at least looks consistent. This removes the need to initially develop HTML and CSS for layout elements like headers and footers, or menus, all you have to do is use those elements that Bootstrap has pre-defined. You can of course alter these pre-defined elements but at least you don't have to design them when you are also struggling to implement all of the actual functionality.

\paragraph{} Because the Flask static directory hosts files that can be served up directly to the client, static is also the natural home for the Bootstrap files. Your HTML templates can then reference these CSS and Javascript files so that they are served to the client when a request is made.

\paragraph{} As your web-app grows it is important to maintain control and organisation of your source code so I find that it is a good idea to create a hierarchy of directories within /static/ in which to store your bootstrap files, for example,

\begin{lstlisting}[style=DOS]
static/
static/css/
static/font/
static/ico/
static/img/
static/js/
\end{lstlisting}

\paragraph{} For the moment though we can use the directory hierachy that Bootstrap comes with. Change directory into your static directory  then download Bootstrap from \url{https://github.com/twbs/bootstrap/releases/download/v3.3.5/bootstrap-3.3.5-dist.zip} and unpack it, e.g.

\begin{lstlisting}[style=DOS]
    $ curl -L -o bootstrap.zip https://github.com/twbs/bootstrap/releases/download/v3.3.5/bootstrap-3.3.5-dist.zip
    $ unzip bootstrap.zip
\end{lstlisting}

\paragraph{} Now move the bootstrap files into directory hierarchy that you created. For example, assuming you are in the static directory and you downloaded the bootstrap zip file

\begin{lstlisting}[style=DOS]
    $ cp -R bootstrap-3.3.5-dist/* .
\end{lstlisting}

\paragraph{} This should recursively copy all of the folder from within the bootstrap directory into the static directory.

\paragraph{} We are now set up to start to use bootstrap to provide some style. But first, let's create an unstyled page, using a Jinja2 template and a simple Flask app that returns an HTML page using the template. We will then extend the template to add some bootstrap functionality to it. So, let's start with the basic template:

\begin{lstlisting}
<html>
<head>
<title>Bootstrap Demonstation</title>
</head>
<body>
<h1>HELLO</h1>
<h2>Napier</h2>
<p>Demonstrating a flask app with templates for html generation and bootstrap
for a little bit of style</p>
</body>
</html>
\end{lstlisting}

\paragraph{} Now we need a basic Flask app that uses the template:

\begin{lstlisting}
from flask import Flask, render_template
app = Flask(__name__)

@app.route('/')
def root():
  return render_template('base.html'), 200

if __name__ == "__main__":
  app.run(host='0.0.0.0', debug=True)
\end{lstlisting}

\paragraph{} Take a look at how your unstyled Flask app appears in the browser. Not very pretty is it?  

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{images/unstyled.png}
\caption{The unstyled HTML page for the Bootstrap example}
\label{fig:unstyled}
\end{figure}

Now let's use Flask to add some basic styling to that ugly old page.

\begin{lstlisting}
<html>
<head>
  <title>Bootstrap Demonstation</title>
  <link href="{{ url_for('static', filename='css/bootstrap.min.css') }}" rel="stylesheet" />
</head>
<body>
<h1>HELLO</h1>
<h2>Napier</h2>
<p>Demonstrating a flask app with templates for html generation and bootstrap
for a little bit of style</p>
</body>
</html>
\end{lstlisting}

\paragraph{} Notice how all we have done is add a relative link, in line 4, to the Bootstrap CSS file. Also note that we used the url\_for function to get the root of the static directory and that all of the URL aspects are enclosed in Jinja2's double curly braces.  Even, just including the bootstrap CSS has already got things looking different:

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{images/styled-css.png}
\caption{After only including the Bootstrap CSS file}
\label{fig:styled-css}
\end{figure}

\paragraph{} But let's go a little further an implement the basic Bootstrap template:

\begin{lstlisting}
<html>
<head>
  <title>Bootstrap Demonstation</title>
  <link href="{{ url_for('static', filename='css/bootstrap.min.css') }}" rel="stylesheet" />
  <style>
    body{ 
      padding-top: 50px;
    } 
  </style>
</head>
<body>

  <nav class="navbar navbar-inverse navbar-fixed-top">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed"
      data-toggle="collapse" data-target="#navbar" aria-expanded="false"
      aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="#">ProjectName</a>
      </div>
      <div id="navbar" class="collapse navbar-collapse">
      <ul class="nav navbar-nav">
        <li class="active"><a href="#">Home</a></li>
        <li><a href="#about">About</a></li>
        <li><a href="#contact">Contact</a></li>
       </ul>
       </div>
    </div>
  </nav>

   <div class="container">
        <h1>HELLO</h1>
        <h2>Napier</h2>
        <p class="lead">Demonstrating a flask app with templates for html generation and bootstrap for a little bit of style</p>
  </div>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
  <script src="{{ url_for('static', filename='js/bootstrap.min.js') }}"></script>
</body>
</html>
\end{lstlisting}

\paragraph{} There are a few things to note here. Firstly we had to add an extra inline CSS script element to push the page content below the navigation bar. Remove this line (line 6) to see what would happen otherwise. After that you can see that we used to containers, the first containing our navigation bar, and the second containg our page content. Finaly we added a pair of script links, the first to JQuery\footnote{\url{https://jquery.com/}} and the second to the default Bootstrap Javascript file which is in our static directory. Look on the Bootstrap website to find out what you can do with the Bootstrap Javascript, and on the JQuery homepage to see what functionality JQuery offers you.

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{images/bootstrap-template-expanded.png}
\caption{Bootstrap example with navigation bar}
\label{fig:bootstrap-example-expanded}
\end{figure}

\paragraph{} And this is what our page looks like in responsive mode, with a mobile style menu button:

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{images/bootstrap-template-responsive.png}
\caption{Bootstrap example in responsive mode}
\label{fig:bootstrap-example-responsive}
\end{figure}


\paragraph{} The bootstrap site demonstates most of the features of bootstrap so you can see how things should look by default. It is also often useful to view the source of a given example element on the bootstrap site in order to see how it should be used. To find out about all of the things that you can do with bootstrap visit \url{http://getbootstrap.com/getting-started/}. Once you have got to grips with the default bootstrap there are also sites that offer additional, free, bootstrap based themes, e.g.

\begin{itemize}
\item \url{http://startbootstrap.com/}
\item \url{http://www.bootstrapzero.com/}
\end{itemize}

\paragraph{} Finally, if you can't find something that you like, then you can always just extend or alter the default Bootstrap themes by editing their CSS. Whatevery you choose to do, Bootstrap is a good way to quickly get a not too bad looking site knocked together.

%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%
% CHAPTER 08
%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%

\chapter{Data Storage}
\label{lab08}
\paragraph{} Many web-apps are increasingly data driven. Whilst there are discussions to be had about the correct balance of static and dynamic functionality\footnote{A completely static website, e.g. one that has been designed to be static or has been `\emph{flattened}' can be {\bf{very}} scalable. The equipment that powered Github pages was for many years very modest yet made tens of thousands of static web-pages for many open source projects. \emph{NB.} Github pages also hosts the web pages for this module as well as hosting our public source code repository.}, it is often the case that a database is an important part of managing the data associated with a web site.

\section{Brief Introduction to SQLite3}
\label{sqlite3-intro}
\paragraph{} The easiest way to get started with data storage for this module is to use SQLite3. SQLite3 is a self-contained, high-reliability, embedded, full-featured, public-domain, SQL database engine. It is also considered to be the most used database engine in the world, embedded within many apps, the default datastore on Android, and providing database functionality to support many websites.

\paragraph{} First we need to install SQLite3. As we're on Ubuntu, which is a Debian based version of Linux, we have access to the Advanced Packing Tool (APT) which we can use to manage the installation of SQLlite3. We only need to install SQLite3 once, and then it's available on the system for us to use in the future, so let's go ahead and do that now. Note that we are installing a system wide piece of software, available by default to all loggrf in users of our VM, so we have to use the sudo command to execute the installation as an admin user:


\begin{lstlisting}[style=DOS]
    $ sudo apt get install sqlite3
\end{lstlisting}

Now it's installed you can run the command line SQLite3 client by executing the following command:

\begin{lstlisting}[style=DOS]
    $ sqlite3
\end{lstlisting}

\paragraph{} This gives us a command line, a bit like the Python REPL, which we can use to directly manipulate and work with SQLite databases. I recommend exploring the SQLite3 documentation\footnote{\url{https://sqlite.org/index.html}} a little and learning about manipulating SQLite databases solely within the SQLite tools before proceeding to using other languages. The command line SQLite3 client looks like this:

\begin{lstlisting}[style=DOS]
    $ sqlite3 
    SQLite version 3.28.0 2019-04-15 14:49:49
    Enter ".help" for usage hints.
    Connected to a transient in-memory database.
    Use ".open FILENAME" to reopen on a persistent database.
    sqlite> 
\end{lstlisting}

\paragraph{} To exit the SQLite3 command line client and return to our terminal we can type .exit then hit return like so\footnote{Alternatively, you can send an end-of-file signal using the $<$ctrl$>$-d key combination which should also shut down the SQLite3 command line client. $<$Ctrl$>$-c and the related quit signal $<$ctrl$>$-c are useful tricks to have up your sleeve if you want to kill a piece of command line software that you're stuck without resorting to the nuclear option of closing the entire window and ending the session.}:

\begin{lstlisting}[style=DOS]
    $ sqlite3 
    SQLite version 3.28.0 2019-04-15 14:49:49
    Enter ".help" for usage hints.
    Connected to a transient in-memory database.
    Use ".open FILENAME" to reopen on a persistent database.
    sqlite> .exit
    $
\end{lstlisting}


\paragraph{} You can also find out a little more about using this tool by typing .help into the tool. We can leave the SQLite tool by typing .exit which should return us to the regular bash shell. Remember that a database can be used independently of any given software or website so it is useful to be able to interact with our database independently of Python and Flask. To do this we could use the command line client mentioned above, or else there are a lot of third party tools for managing SQLite databases\footnote{Some of these tools are graphical tools for those of you who like that kind of thing ;)}.


\paragraph{} However we probably really want to work with SQlite from a programming langauge, like Python, because this gives us a way to link our website, or really any piece of software we are writing, to an SQLite database. Using SQLite3 from Python is quite straightforward if you have worked with a relational database before. You will need to import the Python SQLite3 interface library, set a location where the SQLite database will be stored, and initialise a connection to the DB. First though you need to create a database file. I usually store database files in a ``var'' directory. So go ahead and create a directory called var then create a file within that called sqlite3.db.

\begin{lstlisting}[style=DOS]
    $ mkdir var
    $ touch var/sqlite3.db
\end{lstlisting}


\paragraph{} We can now use that empty file we just created, sqlite3.db, from Python. Let's explore this for a moment. Instead of diving right into Flask let's just use the Python REPL and manipulate our new database a little to get a feel for interacting with it.  For example, start a Python shell (by typing python3 in the bash shell) then:

\begin{lstlisting}[style=DOS]
    >>> import sqlite3
    >>> DB = 'var/sqlite3.db'
    >>> conn = sqlite3.connect(DB)
    >>> cursor = conn.cursor()
\end{lstlisting}

\paragraph{} In this case we have performed our imports, then created a DB object that stores the location and name of our database file, e.g. sqlite3.db which is stored in the relative \emph{var} directory. We then connected to our database file and stored the connection in the variable called \emph{conn} before retrieving a cursor that we can use to work with our database connection.

\paragraph{} Now we have retrieved a cursor we can use it to insert and remove data from our database as well querying the data stored in it. First though, we need to set up a table. Let's create a table to store music called \emph{albums}.

\begin{lstlisting}[style=DOS]
    >>> cursor.execute(""" CREATE TABLE albums
    ... (title text, artist text, release_date text, publisher text, media_type text)
    ... """)
    <sqlite3.Cursor object at 0x1054ec570>
    >>> conn.commit()
\end{lstlisting}

\paragraph{} Notice that we used a multi-line Python string which is wrapped in triple quotes. Now we can add some data to our database, lets add a couple of albums:

\begin{lstlisting}[style=DOS]
    >>> cursor.execute('INSERT INTO albums VALUES ("Greatest Hits", "Roy Orbison", "30.11.1977", "SWRecords", "vinyl")')
    <sqlite3.Cursor object at 0x1054ec570>
    >>> conn.commit()
\end{lstlisting}

\paragraph{} We can use a simple SQL query to see the contents of our fledgeling database as follows:

\begin{lstlisting}[style=DOS]
    >>> for row in cursor.execute("SELECT rowid, * FROM albums ORDER BY artist"):
    ...   print row
    ...
\end{lstlisting}

\paragraph{} We can also use SQL to carry out more complex queries but the following should give us a flavour of what we can do:

\begin{lstlisting}[style=DOS]
    >>> sql = "SELECT * FROM albums WHERE artist=?"
    >>> cursor.execute(sql, [("Roy Orbison")])
    <sqlite3.Cursor object at 0x1054ec570>
    >>> cursor.fetchall()
    [(u'Greatest Hits', u'Roy Orbison', u'30.11.1977', u'SWRecords', u'vinyl')]
\end{lstlisting}

\paragraph{} In this case we just defined an SQL statement which we stored in the sql variable then we executed that statement using the cursor.execute function and a supplied term ``Roy Orbison'' to search for. As this matched a record in the database we had a record in the list that cursor.fetchall() returns. We can also use wildcards and the SQL ``like'' keyword to find close but not exact matches to our query term, e.g.

\begin{lstlisting}[style=DOS]
    >>> term = "orbi"
    >>> cursor.execute("SELECT * FROM albums WHERE artist LIKE '%{term}%'".format(term=term))
    <sqlite3.Cursor object at 0x1054ec570>
    >>> cursor.fetchall()[(u'Greatest Hits', u'Roy Orbison', u'30.11.1977', u'SWRecords', u'vinyl')]
\end{lstlisting}

\paragraph{} For more advanced SQL queries we should look to the SQL documentationbecause this module isn't really about SQL query construction. For now however we can move on to look at how to integrate an SQLite3 database with Flask.

\section{Using SQLite3 with Flask}
\label{sqlite3-flask}
\paragraph{} Now we have seen how SQLite3 works with Python as a general data storage mechanism we can now look at how, with the addition of a few simple functions, we can provide a robust mechanism for storing our web-app's data.

\paragraph{} We'll start with defining a schema file (schema.sql) that can be used to initialise our database as follows:

\begin{lstlisting}
DROP TABLE if EXISTS albums;

CREATE TABLE albums (
    title text,
    artist text,
    media_type text
);
\end{lstlisting}

\paragraph{} This schema just deletes any existing table called `albums' then create a new table called `albums' with three text fields to store the `title', `artist' and `media type' of the albums. We can now use the schema in a Flask file. Let's look at a basic Flask app (datastore.py) that includes a single route and some datastorage using SQLite3:

\begin{lstlisting}
from flask import Flask, g
import sqlite3

app = Flask(__name__)
db_location = 'var/test.db'

def get_db():
    db = getattr(g, 'db', None)
    if db is None:
        db = sqlite3.connect(db_location)
        g.db = db
    return db

@app.teardown_appcontext
def close_db_connection(exception):
    db = getattr(g, 'db', None)
    if db is not None:
        db.close()

def init_db():
    with app.app_context():
        db = get_db() 
        with app.open_resource('schema.sql', mode='r') as f:
            db.cursor().executescript(f.read())
        db.commit()

@app.route("/")
def root():
    db = get_db()
    db.cursor().execute('insert into albums values ("American Beauty", "Grateful Dead", "CD")')
    db.commit()

    page = []
    page.append('<html><ul>')
    sql = "SELECT rowid, * FROM albums ORDER BY artist"
    for row in db.cursor().execute(sql):
        page.append('<li>')
        page.append(str(row))
        page.append('</li>')

    page.append('</ul></html>')
    return ''.join(page)

if __name__ == "__main__":
    app.run(host="0.0.0.0", debug=True)
\end{lstlisting}

\paragraph{} There are four things to notice here:

\begin{enumerate}
\item The init\_db function loads our schema file and initialises a new database. We could call init\_db() each time we restart the app but this would re-initialise the data each time. Instead we will create a separate external file that calls this function whenever we need it \emph{we shall come back to this in a moment}.
\item The get\_db function can be called from within a route to get access to our database connection, e.g.
\begin{lstlisting}[style=DOS]
db = get_db()
\end{lstlisting}
and we can then get a cursor using
\begin{lstlisting}[style=DOS]
db.cursor()
\end{lstlisting}
\item The close\_db\_connection function is a \emph{decorated} function that is automatically called to close the db connection whenever necessary. This is usually when a request end which causes that current context of the flask app to end.
\item Our root function which defined the `/' route does two things, it stores a new album in the database each time the route is accessed. Secondly, this function executes a simple SQL query to retrieve all the entries from the albums table then constructs a small HTML file to display those entries. 
\end{enumerate}

\paragraph{} If we now run this flask app then we will get an error when we hit the `/' route so there is one last thing to do. The error occurs because we don't call the init\_db function from anywhere. We probably only want to do this once when we deploy our web-app, otherwise we will lose all of the contents of the DB so we can create an external Python script, `init\_db.py', that will import the init\_db function then execute it to initialise a new database.

\begin{lstlisting}
from datastore import init_db
init_db()
\end{lstlisting}

\paragraph{} We can now call our script before we start our flask app for the first time to initialise the database as follows:

\begin{lstlisting}[style=DOS]
$  python3 init_db.py
\end{lstlisting}

\paragraph{} This should be enough SQLite3 and Flask integration to get started storing data. Obviously there is lots more to learn about the functionality that SQLite3 offers but that is an exercise for your self-directed study.

\paragraph{} There are many data storage mechanisms and the availabilty of high-quality and performant datastores has increased greatly in recent years with the advent of the NoSQL approach. This approach suggests that there are {\bf{N}}ot {\bf{O}}nly {\bf{SQL}} based approaches to storing data but many approaches, and the one that you choose should be based upon a sound assessment of the nature of the problem that you are tackling as well as the knowledge and experience of your development team. So, for example, there are a number of column-oriented, document oriented, graph-oriented, and key-value datastores, and many hybrids, which can be very useful when developing new web-apps. For example, when trying out various solutions to a problem it can be useful to use a schemaless datastore to hold your initial attempts at building a data model so that you do not waste time prematurely attempting to identify good database schema or relational models. 

%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%
% CHAPTER 09
%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%

\chapter{Keeping Data safe with Encryption}
\label{lab09}
\paragraph{} Encryption is necessary to ensure that the data that we collect in our web-apps, for example, about our users, is stored safely. A good general approach is to not store any data about your users that you don't actually need for the purposes of your application.


\section{Using PyCryptoDome Library for data encryption}
\label{pycryptodome}
\paragraph{} PyCryptoDome\footnote{\url{https://www.pycryptodome.org/en/latest/}} is the Python Cryptography Toolkit and provides a range of useful tools for encrypting and working with encrypted data in Python. 

\paragraph{} PyCryptodome is a Python library that incorporates some useful cryptography tools. We can install it as follows:
\begin{lstlisting}[style=DOS]
    $ pip3 install --user pycryptodome
    $
\end{lstlisting}

\paragraph{} We can now check that this library is installed properly by using the following command:
\begin{lstlisting}[style=DOS]
    $ python3 -c "import Crypto"
    $
\end{lstlisting}

\paragraph{} If you get any output other than a new prompt then the library is not available (in which case you should contact the module leader for a fix). You can now import and use PyCryptodome within your web-apps, however let's first explore what the library can do in the Python REPL, so launch python in your shell, e.g.

\begin{lstlisting}[style=DOS]
    $ python3
\end{lstlisting}

\paragraph{} We can now look at some of the things that we can use PyCryptodome to do. First we shall look at Hashing, taking input and calculating a fixed-length output called a hash-value, then we will look at Encryption, taking input and a key and producing a cypher text. The main difference between the two in practise is that hash algorithms are designed, as a rule, to be one-way or \emph{trapdoor} functions, whilst, so long as you know the key, encryption algorithms are designed to enable you to recover the input from the cyphertext.

\subsection{Hashing}
\paragraph{} The idea with Hashing is to take as input a string and calculate a fixed length output string called the \emph{hash value}. This is a useful way to quickly determine whether two strings are the same, for example if wanting to ensure that the string that was transmitted is the one that was received. In that case we would calculate the hash value associated with the string, then transmit both the string and the hash value to the remote recipient who then recalculates the hash value from the string then compares the two hash values. if they differ then the string was altered in transit and if they are the same the string that was recieved is the one that was sent. This kind of usage is called \emph{file integrity checking} but is also known as \emph{checksumming} or \emph{calculating a checksum}.

\paragraph{} Hashing relies on various assumptions:

\begin{enumerate}
\item It should be very difficult (if not impossible) to guess the input string based upon the output string
\item It should be very difficult (if not impossible) to find two different input strings that have the same output (known as a \emph{collision})
\item It should be very difficult (if not impossible) to modify the input string without also modifying the hash value as a result.
\end{enumerate}

\paragraph{} We can hash a value, e.g. a string, using a range of hash functions but we can start with SHA256. First we will hash the value passed directly to SHA256 then we will compare it to the same value stored in a string and passed in, and a different value:

\begin{lstlisting}[style=DOS]
    >>> from Crypto.Hash import SHA256
    >>> SHA256.new('Hello Napier'.encode('utf-8')).hexdigest()
    '8fa01d2f5f442915112a4c98d5c65c909f8b5532f01102371cf81776b91e5694'
    >>>
    >>> hello_napier = 'Hello Napier'.encode('utf-8')
    >>> SHA256.new(hello_napier).hexdigest()
    '8fa01d2f5f442915112a4c98d5c65c909f8b5532f01102371cf81776b91e5694'
    >>> 
    >>> SHA256.new('Goodbye Napier'.encode('utf-8')).hexdigest()
    'ebccfcde2209e3dff4deff67fdbae71129ea87692e40295768de48317244347e'
    >>>
\end{lstlisting}

\subsection{Encryption with Block Cyphers}
\paragraph{} Block cyphers work on their input data in \emph{blocks} of a fixed size, for example, blocks of 8 or 16 bytes in length. We'll use the Data Encryption Standard (DES)\footnote{\url{https://en.wikipedia.org/wiki/Data_Encryption_Standard}} as our example. The basic form of DES is pretty comprehensively broken as a secure encryption standard, however Triple-DES is still considered secure. There are many cryptographic algorithms available and for real-world uses it is worth investigating current best cryptographic practises and algorithms to adopt. DES works in various modes, e.g. Electronic CodeBook (ECB) mode or Cypher Feedback (CFB) mode amongst others. We will start with a demonstration of encrypting data using ECB.

\begin{lstlisting}[style=DOS]
    >>> from Crypto.Cipher import DES
    >>> des = DES.new(b'secret!!', DES.MODE_ECB)
    >>> test = b'greeting'
    >>> cipher_text = des.encrypt(test)
    >>> cipher_text
    b'(\xe5H\xe8\x10k\xc1['
    >>> 
    >>> des.decrypt(cipher_text)
    b'greeting'
    >>> 
\end{lstlisting}

\paragraph{} Notice that we first imported the DES part of the library. We then create a new DES instance, set the mode `DES.MODE\_ECB' and our encryption key '01234567'. We then used DES to encrypt our input string to yield a cipher text. After that we decryped our cipher text to recover the original data.

\paragraph{IMPORTANT} A limitation of DES is that the key must be exactly 8 Bytes longs and the data that is encrypted must be a multiple of 8 Bytes in length. Obviously our data will seldom be a multiple of 8 Bytes so we often need to pad the data up to the next multiple of 8 Bytes.

\paragraph{} Now let's try a different DES mode, DES CFB, to encrypt and descrypt some data. Of interest with CFB mode is that instead of each block being encrypted individually to form the cipher text each block in CFB mode is combined with the previously encrypted block. This time we shall use a slightly longer plain text to give a more interesting message, but still stick to the multiples of 8 Bytes rule. This is because we need more than one block for the combination step to work. 

\begin{lstlisting}[style=DOS]
    >>> from Crypto.Cipher import DES
    >>> from Crypto import Random
    >>> feedback_value = Random.get_random_bytes(8)
    >>> des_enc = DES.new(b'secret!!', DES.MODE_CFB, feedback_value)
    >>> txt = b"Hello World From Napier"
    >>> cipher_txt = des_enc.encrypt(txt)
    >>> cipher_txt
    b"\xea\xa2\x81/\x9f\xc6\x80\xbf\xd8\xeef\x81\x89M\x8f'\xe7\x9eB\xa7\xb8\xd7\xd6"
    >>> des_dec = DES.new(b'secret!!', DES.MODE_CFB, feedback_value)
    >>> des_dec.decrypt(cipher_txt)
    b'Hello World From Napier'
\end{lstlisting}


\paragraph{} Notice that this is fairly similar to the ECB version earlier. The are two main points to notice. The first is that the DES object now takes a third argument, an 8 Byte random string and we use the Random function of the Crypto package to supply us with random data\footnote{It is worth noting that often the quality of encryption depends upon the quality of the randomness that is supplied to the algorithm. It is actually quite hard to get truly random numbers from a computer and even small statistical regularities in the randomness can be sufficient to break the encryption}. The main difference is that we have created two DES objects this time, one to encrypt and one to decrypt. This is necessary because of the combination step, that occurs after each block is encrypted which alters the feedback value.

\subsection{Encryption with Stream Cyphers}
\paragraph{} Stream cyphers differ from Block cyphers by working on byte-by-byte on their input data, treating the data as a stream instead of discrete blocks. Stream cyphers are essentially block cyphers in which the block size is 1 Byte in length. PyCryptodome only supports two stream cyphers, ARC4 and XOR, in ECB mode. Let's look at an example of using the ARC4 algorithm:

\begin{lstlisting}[style=DOS]
    >>> from Crypto.Cipher import ARC4
    >>> arc4_enc = ARC4.new(b'01234567')
    >>> arc4_dec = ARC4.new(b'01234567')
    >>> txt = b"Hello World from Edinburgh Napier University"
    >>> cyphertxt = arc4_enc.encrypt(txt)
    >>> cyphertxt
    "\xd9\xb0\x9fs)\x07r_B?\xdfz\x94\xdc\x8c='\x8b.9@\x1e\xe3@\xc68K\x1c\x18:\xad\xc3:~\xf9\x95wa\xbcB\xa0U\x08\xe9"
    >>> arc4_dec.decrypt(cyphertxt)
    'Hello World from Edinburgh Napier University'
\end{lstlisting}


\subsection{Public Key Encryption}
\paragraph{} Correctly selected and used instances of stream and block cyphers are acceptably secure and performant. However they have a fundamental flaw, in certain contexts, that is common to all security systems. People. These cyphers require both the people encrypting and the people decrypting to share the same key. Key management is a big problem, if not the major problem, that makes things like email encryption difficult for the average computer user. As a result, the average email might as well be written on a postcard.

\paragraph{} Public-key encryption uses two keys, known as a key-pair to encrypt and decrypt data. The two keys in a key pair are created together using an algorithm than ensure that they are mathermatically related to each other. One key is designated the public key and the other key is designated the private key. The public key can be shared with anyone whereas the private key is kept private and known only to the person who owns it. The public key is then used to encrypt some data and the private key is used to decrypt it. Because of the mathematical relation between the public and private key, data that is encrypted with one key cannot be decrypted with the same key but most be decryped using the key's partner. One way to think about this is like using a padlock and key. You give some one a box and padlock. They put a message in the box, then they lock the box with your padlock and only you can unlock it with your key. Things are actually more complicated than this in practise but this is a good place to start from. Keys are actually very long numbers, very long prime numbers to be specific and generally, the longer the key the more secure the key. PyCryptodome provides functions for generating keys, e.g.

\begin{lstlisting}[style=DOS]
    >>> from Crypto.PublicKey import RSA
    >>> key = RSA.generate(2048)
    >>> private_key = key.export_key()
    >>> file_out = open("private.pem", "wb")
    >>> file_out.write(private_key)
    1674
    >>> file_out.close()
    >>> 
    >>> 
    >>> public_key = key.publickey().export_key()
    >>> file_out = open("receiver.pem", "wb")
    >>> file_out.write(public_key)
    450
    >>> file_out.close()
\end{lstlisting}

\paragraph{} If you look in the folder that you ran the previous Python code in then you should notice a pair of new files. Theses are the public and private keys we just created. Having created a key-pair we can now use the public key to encrypt some data and then the private key to decrypt it. Let's start with using the public key to encrypt something, e.g.

\begin{lstlisting}[style=DOS]
    >>> from Crypto.PublicKey import RSA
    >>> from Crypto.Random import get_random_bytes
    >>> from Crypto.Cipher import AES, PKCS1_OAEP
    >>> data = "Soylent Green is people".encode("utf-8")
    >>> file_out = open("encrypted_data.bin", "wb")
    >>> recipient_key = RSA.import_key(open("receiver.pem").read())
    >>> session_key = get_random_bytes(16)
    >>> cipher_rsa = PKCS1_OAEP.new(recipient_key)
    >>> enc_session_key = cipher_rsa.encrypt(session_key)
    >>> cipher_aes = AES.new(session_key, AES.MODE_EAX)
    >>> ciphertext, tag = cipher_aes.encrypt_and_digest(data)
    >>> [ file_out.write(x) for x in (enc_session_key, cipher_aes.nonce, tag, ciphertext) ]
    [256, 16, 16, 37]
    >>> file_out.close()
\end{lstlisting}

\paragraph{} Having encrypted some data with the public key (\emph{receiver.pem}), we can now go ahead a decrypt the file we just created \emph{encrypted\_data.bin} using our private key (\emph{private.pem}).

\begin{lstlisting}[style=DOS]
    >>> from Crypto.PublicKey import RSA
    >>> from Crypto.Cipher import AES, PKCS1_OAEP
    >>> file_in = open("encrypted_data.bin", "rb")
    >>> private_key = RSA.import_key(open("private.pem").read())
    >>> enc_session_key, nonce, tag, ciphertext = 
        [ file_in.read(x) for x in (private_key.size_in_bytes(), 16, 16, -1) ]
    >>> cipher_rsa = PKCS1_OAEP.new(private_key)
    >>> session_key = cipher_rsa.decrypt(enc_session_key)
    >>> cipher_aes = AES.new(session_key, AES.MODE_EAX, nonce)
    >>> data = cipher_aes.decrypt_and_verify(ciphertext, tag)
    >>> print(data.decode("utf-8"))
    Soylent Green is people
\end{lstlisting}

\paragraph{} A couple of other useful things that we can do with the RSA algorithm are to sign and verify messages. We can sign a message using a public key and a hash algorithm in order to establish two things (1) that the message hasn't changed during transmission, and (2) that the origin, meaning the person who sent the message, can be trusted. Notice that this only holds if the key pair has not been compromised. This is the main reason why effective secure communications is difficult, because managing and sharing keys on a large scale is difficult, even for experienced computer users, and small mistakes can easily leave the entire system nearly as insecure as it would be without encryption. In fact some might say that a system that uses insecure encryption is worse, because you might believe it to be secure whereas within an un-encrypted system you already know not to trust it.

\paragraph{} So let's sign a message, first we import a few libraries. Then we prepare a message and load in an existing key (\emph{receiver.pem}). We then calculate a hash-value for the message and sign it using our RSA key, e.g.

\begin{lstlisting}[style=DOS]
    >>> from Crypto.Signature import pkcs1_15
    >>> from Crypto.Hash import SHA256
    >>> from Crypto.PublicKey import RSA
    >>>
    >>> message = b'My namie is Inigo Montoya. You killed my father. Prepare to die.'
    >>> key = RSA.import_key(open('private.pem').read())
    >>> h = SHA256.new(message)
    >>> signature = pkcs1_15.new(key).sign(h)
\end{lstlisting}

\paragraph{} Given the plain text, the signature, and the public key (but \emph{not} the private key) the recipient of a message can now check that the message that was sent both came from the person who owns the private key but also that the messages hasn't been maliciously altered during transmission, e.g.

\begin{lstlisting}[style=DOS]
    >>> key = RSA.import_key(open('receiver.pem').read())
    >>> h = SHA256.new(message)
    >>> try:
    ...     pkcs1_15.new(key).verify(h, signature)
    ...     print("The signature is valid.")
    ... except(ValueError, TypeError):
    ...     print ("The signature is not valid.")
    ... 
    The signature is valid.
\end{lstlisting}

\paragraph{} Public Key cryptography is an important tool in the fight to ensure that we can communicate in ways that are secure from eavesdropping, non-repudiable (meaning the person who sent it can be verified as such), and unaltered.

\section{Using py-bcrypt Library for Password Hashing}
\label{py-bcrypt}
\paragraph{} Hash functions can be used in password management and storage. Web sites should only store the hash of a password and not the raw password itself. This way only the user knows the real password. When the user logs in, the hash of the password input is generated and compared to the hash value stored in the database. If it matches, the user is granted access\footnote{If you ever use a website that can help you to \emph{recover} your password then they probably aren't hashing passwords. In this case you should probably question the security of that site and their ability to keep your data safe.}. Whilst you could use the hashes available in PyCryptodome for user passwords, this is no longer the most secure approach. Rather you should use a type of password hash that has been specifically designed for use to store password hash-values and thus mitigates many of the drawbacks of generic cyrptographic hash functions in this context. Such hashes are known as \emph{key derivation functions} and are designed to significantly slow down the process of hashing a value so that brute force attacks, where you try to calculate all possible hashes, become significantly expensive in terms of time to calculate. This contrasts with hashes used for checksumming, which obviously need to run as fast as possible. 

\paragraph{} BCrypt is the OpenBSD Blowfish password hashing algorithm that is described in a paper by Niels Provos and David Mazieres called "A Future-Adaptable Password Scheme"\footnote{\url{http://www.openbsd.org/papers/bcrypt-paper.ps}}. There is a Python wrapper for this algorithm called py-bcrypt\footnote{\url{http://www.mindrot.org/projects/py-bcrypt/}} that you should use to hash password in your web-apps, at least until this algorithm is demonstrated to be flawed or a stronger system is proposed.

\paragraph{} The BCrypt library isn't yet installed so you'll need to install it as follows:

\begin{lstlisting}[style=DOS]
    $ pip3 install --user bcrypt
    $
\end{lstlisting}

\paragraph{} Now check that it's installed properly with the following command. Again, if you get any output other than the return of the prompt `\$' then you should contact the module leader for a fix: 
\begin{lstlisting}[style=DOS]
    $ python3 -c "import bcrypt"
    $
\end{lstlisting}

\paragraph{} As well as implementing a password derivation algorithm, bcrypt can also salt the supplied password so that the hashed-value is more resistant to rainbow-table based attacks. When you use the hashpw function, you can either pass in the pre-generated salt or else call gensalt() directly and the salt is stored within the generated hash-value. To hash a password we do the following:

\begin{lstlisting}[style=DOS]
    >>> import bcrypt
    >>> hash = bcrypt.hashpw('secretpassword'.encode('utf-8'), bcrypt.gensalt())
    >>> hash
    b'$2b$12$5KkwUyRUDEooMWAMBOLdnuiOIJPvG2dYmP5nNyhSs1hW1xdovn0Ni'
\end{lstlisting}

\paragraph{} First we import bcrypt, then we create a new hashed value using the supplied password and asking bcrypt to generate a salt. We only need to store the hash-value after that as the salt is stored within the hash-value. For example, you could now store the hash-value in your user database. When we need to verify a user's password we would do the following, assuming that you have retrieved the hash-value from your user DB as `hash' and that the supplied password is stored in `pass':

\begin{lstlisting}[style=DOS]
    >>> hash == bcrypt.hashpw('secretpassword'.encode('utf-8'), hash)
    True
\end{lstlisting}

\paragraph{} and if the supplied password is incorrect we will see something like this:

\begin{lstlisting}[style=DOS]
    >>> hash == bcrypt.hashpw('badpassword'.encode('utf-8'), hash)
    False
\end{lstlisting}

\paragraph{} This should be enough to get you started in storing your user's data securely. The rule of thumb is to keep your security arrangements as simple as possible because unwarranted complexity can hide weaknesses. You should also not implment your own security arrangements if there are already well tested alternatives. Encryption is a game for specialists and the liklihood is that you will not crate anything as good as what is already available.


\section{Secure login with BCrypt \& Flask}
\label{login}
\paragraph{} Now let's combine our use of bcrypt for password hashing with some Flask decorators and Python functions so that we can protect specified routes from being accessed by users who have not supplied the correct credentials. We'll start by breaking down what we need in our Flask app. Firstly we need some routes, a default `/' route, a `/secret/' route, and a `/logout/' route. Secret is the route that we will protect from access by unauthorised users. The default route will present a login form then check the login credentials and will either reshow the login form, if authorisation fails, or else redirect to the secret route if our login is successful. Finally our logout route is used to reset the authorisation within our app as otherwise we would have to delete our cookies each time we wanted to log out.

\paragraph{} We'll start by putting together our simple login form, which should be stored in a \emph{templates} folder under our main python app file:

\begin{lstlisting}
<html>
<head>
</head>
<body>

<form name="login_form" action="" method="post">

    <input type="email" placeholder="Email" name="email">
    <input type="password" placeholder="Password" name="password">
    <button type="submit" class="btn" name="button" value="login">
        Sign In
    </button>

</form>

</body>
<html>
\end{lstlisting}

\paragraph{} As you can see this merely present two input boxes, one each for the email and password respectively, and a button. When the button is pressed the form is POSTed to the route that is listening for it, in our case the \emph{root} route.

\paragraph{} Now let's see the flask app itself which is stored in \emph{login.py}

\begin{lstlisting}
import bcrypt
from functools import wraps
from flask import Flask, redirect, render_template, request, session, url_for

app = Flask(__name__)
app.secret_key = 'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT'

valid_email = 'person@napier.ac.uk'
valid_pwhash = bcrypt.hashpw('secretpass'.encode('utf-8'), bcrypt.gensalt())

def check_auth(email, password):
    if(email == valid_email and 
        valid_pwhash == bcrypt.hashpw(password.encode('utf-8'), valid_pwhash)):
            return True
    return False

def requires_login(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        status = session.get('logged_in', False)
        if not status:
            return redirect(url_for('.root'))
        return f(*args, **kwargs)
    return decorated

@app.route('/logout/')
def logout():
    session['logged_in'] = False
    return redirect(url_for('.root'))

@app.route("/secret/")
@requires_login
def secret():
    return "Secret Page"

@app.route("/", methods=['GET', 'POST'])
def root():
    if request.method == 'POST':
        user = request.form['email']
        pw = request.form['password']
        
        if check_auth(request.form['email'], request.form['password']):
            session['logged_in'] = True
            return redirect(url_for('.secret'))
    return render_template('login.html')

if __name__ == "__main__":
    app.run(host="0.0.0.0", debug=True)
\end{lstlisting}

\paragraph{} Because we are keeping this login example as simple as possible, you will notice that the user credentials are hard-coded into the example using the \emph{valid\_email} and \emph{valid\_pwhash} variables. Notice also that valid\_pwhash doesn't store the password but the hashed and salted version of the password. This means that we cannot easily recover the user's password if they forget it. In a real app we would store these credentials in a user database then retrieve them as required, however we have not included that here in order to simplify the example.

\paragraph{} We also have some utility functions, for example the check\_auth function that takes in an email and password, then compares them to the stored user and hashed password, returning True or False depending upon whether they match or not. 
\paragraph{} Next we have a decorator function called `requires\_login' that we use to \emph{decorate} any Flask route that can only be viewed by a logged in user. If the user is not logged in then they are redirected to the `/' route. The only check that we are doing within this decorator is seeing whether there is a `logged\_in' session variable. If this check evaluates to True then the user is considered to be logged in, and not otherwise.

\paragraph{} The `logout' route merely removes the session variable that determines whether a user is logged in or not then redirects to the `/' route.

\paragraph{} The `secret' route just displays a string indicating that it is secret. Notice the additional decorator on this route. Not only do we have the `@app.route' decorator that tells Flask to treat this function as a web-app route, but we also have the `@requires\_login' route which causes the `requires\_login' function to be run \emph{before} the `secret' route is executed.

\paragraph{} Finally, the `root' route displays our login template. If a POST is received then the check\_auth route is called with the supplied credentials to determine whether the user is logged in.

\paragraph{} This is a relatively low-security way to implement a login mechanism for a Flask app. It is susceptible to various attacks, for example, a replay-attack; if an attacker were to copy a logged in user's cookie into their own browser then they would be treated as logged in, even though they had made no changes to the cookie. They wouldn't however be able to log in again as they would not have valid credentials to do so, so this attack can be mitigated to some degree by setting a timeout on the length of the user's authentication period. Another defence is to use encrypted tokens that increment for each request a user makes so that there is a strict sequence of interactions between the user and the app. If any interaction supplies an incorrect (or reused) token then the user is automatically logged out and asked to supply their credentials. Achieving a secure login that is not in any way vulnerable to attacks is a difficult task but as a developer and designer we should also evaluate the likelihood of various attacks, for example, the replay attack described above would require an attacker to gain access to your users secure cookie stored in their browser which would mean that the user is likely already heavily compromised.

\paragraph{} However all is not lost. If we securely store our user's data and hash passwords and other sensitive data, and if we also follow a privacy-by-design methodology and only store data that is necessary for the effective functionality of our app, we can at least reduce the effects of a successful attack in terms of our user's personal data. If we are also active in logging the behaviour of our app, checking those logs, and reviewing our codebase for known vulnerabilities or attack vectors then we will also be reducing the likelihood of a successful attack occuring.


%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%
% CHAPTER 10
%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%

\include{scratch}

%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%
% CHAPTER XX
%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%


%\begin{comment}
%\chapter{Building Data APIs with HTTP/JSON}
%\label{lab10}
%\paragraph{} 
%\end{comment}


%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%
% CASE STUDIES 
%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%


%\begin{comment}
%\part{Case Studies}
%\chapter{Daybook}
%\label{daybook}
%\paragraph{}
%\end{comment}

%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%
% APPENDICES 
%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%

\part{Appendices}

\appendix
\chapter{Cribsheets}
\label{cribsheets}
\paragraph{} These cribsheets are useful for collecting together lots of new syntax but are no substitute for your own notes (and practise. Stuff you know is much better than stuff you can look up). Either way, as you learn new stuff you should expand these cribsheets with extra commands that you find useful.

\section{Linux}
\label{cribsheet_linux}

\subsection{Some useful aliases}

\begin{description}
\item[{\raise.17ex\hbox{$\scriptstyle\sim$}}] An alias that means your home directory within the filesystem hierarchy. On the Linux dev server, for the user 40001111 this would expand to /home/40001111, e.g. If you are lost in the filesystem then the following will always take you home:
\begin{lstlisting}[style=DOS]
    $ cd ~
\end{lstlisting}

\item[.] An alias that means the current directory. So if you want to explicitly affect something in the current directory you use this. It can help to avoid ambiguity. For example, when running a script, we specify that we want to run the one in the current folder rather than another one on the system executable path:
\begin{lstlisting}[style=DOS]
    $ ./runme.sh
\end{lstlisting}

\item[..] An alias that means the parent of the current directory. So if you want to move from the current directory to it's parent then you can use this:
\begin{lstlisting}[style=DOS]
    $ cd ..
\end{lstlisting}

\item[-] An alias that means the \emph{previous} directory. This is really useful to help you jump between two directories in different parts of the filesystem with something like:
\begin{lstlisting}[style=DOS]
    $ cd -
\end{lstlisting}

\end{description}

\subsection{Some useful commands}
\begin{description}
\item[cat \emph{filename}] Display the contents of the file \emph{filename}
\item[cd] Change to your home directory /home/tc or \textasciitilde/home
\item[cd \emph{..}] Change directory to the parent of the current directory
\item[cd \emph{directoryname}] Change directory to the named directory
\item[ls] List the names of the files in the current directory
\item[ls  \emph{directoryname}] List the contents of the named directory
\item[mkdir \emph{directoryname}] Create a new directory in the current directory
\item[mv \emph{source} \emph{destination}] Move a file (or directory) to a new location
\item[mv \emph{old} \emph{new}] Rename a file (or directory)\footnote{Yes, these two instances of mv are very similar. This is because under the surface mv works by altering a pathname which means that moving a file or folder around the file system is technically the same as renaming a file. When a move happens it is not actually moving a file to another location on disk, just renaming where it is reported as located.}
\item[pwd] Display the path to the current directory in the filesystem hierarchy, e.g. show you where you are relative to the root
\item[rm \emph{filename}] Delete the named file
\item[rm -rf \emph{directoryname}] Will delete the named directory and all of its contents
\item[touch \emph{filename}] Will create a new file called filename
\end{description}

\section{Vim}
\label{cribsheet_vim}
\begin{description}
\item[\$ vim] - Shell command to start a new unnamed empty document in Vim
\item[\$ vim filename.txt] - Shell command to open `filename.txt' in Vim. If it exists then the file will be opened, otherwise an empty file will be opened for editing that will be saved as `filename.txt' when you use the (w)rite command
\item[$<$ESC$>$] - Enter command Mode
\item[$<$ESC$>$i$<$ENTER$>$] Enter (i)nsert edit mode
\end{description}
\paragraph{} The following are a core set of Vim commands that are all used whilst in Command mode, e.g. after typing $<$ESC$>$
\begin{description}
\item[:q$<$ENTER$>$] - (q)uit
\item[:q!$<$ENTER$>$] - (q)uit and discard any changes
\item[:w$<$ENTER$>$] - (w)rite changes to file
\item[:wq$<$ENTER$>$] - (w)rite changes to file then (q)uit
\item[:e \emph{filename} $<$ENTER$>$] - Open file \emph{filename} in Vim for editing
\item[dd$<$ENTER$>$] - Delete the entire line that the cursor is on
\item[x$<$ENTER$>$] - Delete the character that the cursor is on
\item[j] - Move the cursor up one line (NB. You can also use the `up' arrow key
\item[k] -  Move the cursor down one line (NB. You can also use the `down' arrow key
\item[l] -  Move the cursor right one character (NB. You can also use the `right' arrow key
\item[h] -  Move the cursor left one character (NB. You can also use the `left' arrow key
\item[gg] -  Go to start of file	 
\item[G] - Go to end of file
\item[\$] - Move cursor to the end of the current line
\item[0] - Move cursor to start of current line (NB. Thats a zero)
\item[$<$CTRL$>$e] - Scroll up
\item[$<$CTRL$>$y] - Scroll down	
\item[$<$CTRL$>$b] - Page Up	
\item[$<$CTRL$>$f] - Page Down
\item[/\emph{search-term}] - Search forward for `search-term' in the current file (Use `n' for (n)ext match in current direction and (N) for next match in opposite direction)
\item[?\emph{search-term}] - Search backward for `search-term' in the current file (Use `n' for (n)ext match in current direction and (N) for next match in opposite direction)
\item[u] - Undo the last command
\item[.] - Repeat the last command
\end{description}

\paragraph{} Vim has many more commands and many ways in which individual commands can be composed into more complex composite commands. We've seen above a core set of essential commands, now we'll have a smattering of interesting further commands that are useful when editing and will give you a flavour of what Vim has to offer:
\begin{description}
\item[J] - Combine (``join'') next line with this one
\item[nG] - Move cursor to line n, e.g. 1G will take you to the first line of the file
\item[ma] - Mark current position
\item[d`a] - Delete everything from the marked position to here
\item[`a] -  Go back to the marked position] 
\item[:s/s1/s2] - Replace (``substitute'') (the first) s1 in this line by s2
\item[:set number] Turn on line numbering.  Add this to your .vimrc file to have numbers on by default. Use \emph{:set nonumber} to turn line numbers off again.
\end{description}


\chapter{Annotated Code Examples}
\label{annotated}

\section{Python3 Flask `Hello Napier'}
\label{annotated_hello_napier}
\paragraph{} An annotated walk through the code from hello.py that we saw in section \ref{python-flask}.

\begin{lstlisting}
from flask import Flask 
app = Flask(__name__)

@app.route("/")
def hello():
    return "Hello Napier!"

if __name__ == "__main__":
    app.run(host='0.0.0.0')

\end{lstlisting}

\begin{description}
\item[Line 1] \emph{from flask import Flask}\\ 
Import the Flask class from the flask library. The library contains pre-written code and utilities that are useful when writing a web-app. In this case an instance of the Flask class will be our WSGI application.
\item[Line 2] \emph{app = Flask(\_\_name\_\_)}\\
Create an instance of the Flask class. The argument `\_\_name\_\_' is the name of the flask applications module. This is used to help flask to find resources relative to the Python module such as static web resources like image files, templates, or CSS. We also create a variable, `app', that references the newly instantiated Flask class so that we can use it later.
\item[Line 4] \emph{@app.route("/")}\\
Lines that start with @ in Python are decorators. In this case we use the route() decorator to tell Flask which URL should trigger the function that route() decorates, e.g. when a browser hits the root of the url, `/' then the hello() function is run. We use route() decorators in flask to build up our HTTP API that a browser can retrieve.
\item[Line 5] \emph{def hello():}\\
This defines a function called `hello()'. hello() is executed whenever someone requests the root url.
\item[Line 6] \emph{return "Hello Napier!"}\\
All our hello() does is to return the string ``Hello Napier''. It is this string that is displayed in the browser. We could instead return some HTML for a richer experience but plain textis sufficient for now.
\item[Line 8] \emph{if \_\_name\_\_ == "\_\_main\_\_":}\\
This is used to control how the Python module and the flask app server is run. We only want to use app.run() if this script is executed from the Python interpreter, e.g. by calling \$python hello.py. If we were to use an app server instead then the app.run() would be performed differently.
\item[Line 9] \emph{app.run(host='0.0.0.0')
}\\
Calls the run() function of the Flask app class instance to start our development server running using this app as the web app. This line also tells the app to run on a network interface that is accessible from an external address, e.g. from the Windows machine that is running your SSH connection, otherwise our app would only be accessible within the dev server and we don't have a graphical browser installed there.
\end{description}

\chapter{Additional Miscellaneous (but useful) Tools}
\label{additional-tools}

\section{cURL}
\label{curl}
\paragraph{} The cURL tool is a command that you can use to interact with remote HTTP APIs. It can function purely as a download tool in the terminal, for example, in Section \ref{static} we used cURL to retrieve an image file for use in our Flask static file demonstration, e.g.

\begin{lstlisting}[style=DOS]
    $ curl -L siwells.github.io/assets/images/vmask.jpg -o vmask.jpg
\end{lstlisting}

\paragraph{} By default cURL will perform an HTTP GET to the URL that we provide, However we can also specify the HTTP verb that we want to use as an additional arguments to the tool, e.g.

\begin{lstlisting}[style=DOS]
    $ curl -X POST -d "firstName=jebediah" http://dummy.com/persons/person 
\end{lstlisting}
\paragraph{} Notice the use of `-X POST' to specify the verb (which could be any verb defined by the HTTP standard, e.g. GET, POST, PUT, DELETE, HEAD, OPTIONS, \&c.). Some verbs also expect a payload so we have also included one using the `-d' argument and providing a key and value. This could actually be a whole JSON document or separate file that is used as the payload but for now we'll keep things simple.

\paragraph{} We can cause cURL to print extra information by using `-i' option and can also use `-H' to specificy the accept header for the request. In the following case indicating that the payload is of type `application/json'
\begin{lstlisting}[style=DOS]
    $ curl -i -H "Accept: application/json" -X POST -d "firstName=jebediah" http://dummy.com/persons/person 
\end{lstlisting}

\section{Pip}
\label{pip}
\paragraph{} Pip is a package management tool for Python libraries and is really easy to use. You can use pip to install Python libraries into your own user account on the server, e.g.
\begin{lstlisting}[style=DOS]
    $ pip3 install --user PyCryptodome
\end{lstlisting}

\paragraph{} What this does is enter the \emph{superuser} (SU) role, then it installs pip. The superuser role has more powers than a regular user so once we have installed pip we want to exit the superuser role back to the normal user role that we logged in as. The change in role is indicated by the change in prompt that we see from \emph{\$} to \emph{\#}. We can now use Pip to install whichever Python libraries we want to use as a normal user (not as a superuser). 

\paragraph{} First, let's list the installed Python libraries

\begin{lstlisting}[style=DOS]
    $ pip3 freeze
\end{lstlisting}

\paragraph{} It is useful to save the output of pip freeze to a file that you store in your Python app's Git repository so that you can easily reinstall all of the necessary libraries if you need to install your app elsewhere. You can do this as follows:

\begin{lstlisting}[style=DOS]
    $ pip3 freeze > requirements.txt
\end{lstlisting}

\paragraph{} Which will cause the output to be saved in a file called requirements.txt\footnote{There are some opportunities for further exploration here. The `$>$' symbol is a Bash shell redirection operator which means that it causes the output of bash, which is usually printed on screen to be redirected to another location, in this case into a text file.} Have a look at the contents of requirements.txt using either Vim or the cat command in the shell, e.g.

\begin{lstlisting}[style=DOS]
    $ cat requirements.txt
\end{lstlisting}

\paragraph{} Compare the output to that of just using pip freeze without the redirection. It should be exactly the same. Now if we ever wish to reinstall our Python libraries then we can just use the requirements.txt file as the input to pip and it will run through the list and install everything, e.g.

\begin{lstlisting}[style=DOS]
    $ pip3 install -r requirements.txt
\end{lstlisting}

\paragraph{} Now we can get to the meet of Pip, which is installing new Python libraries. We do this using the install argument of Pip, e.g.

\begin{lstlisting}[style=DOS]
    $ pip3 install flask
\end{lstlisting}

\paragraph{} Obviously we already have flask installed on the dev server but if we didn't then we could use this simple command to just install it. 


\chapter{Python Primer}
\label{python-primer}

\paragraph{} The goal of the following sections is to give the shortest possible introduction to the most important features of the Python language that you'll need to become familiar with. Obviously Python can do much more, but this is a good starting place. All the examples are using the Python REPL (which is why the prompt starts with `$>>>$'. If you want to run this code in a script then you might have to make minor adjustments in places.

\section{Variables \& Data Types}

\subsection{Variable Assignment}
\begin{lstlisting}[style=DOS]
    >>> x=5
    >>> x
     5
\end{lstlisting}

\subsection{Performing Calculations With Variables}
\paragraph{} Respectively, addition, subtraction, multiplication, exponentiation, remainded (modulo arithmetic, and division.
\begin{lstlisting}[style=DOS]
    >>> x+2
     7
    >>> x-2
     5
    >>> x*2
     10
    >>> x**2
     25
    >>> x%2
     1
    >>> x/float(2)
     2.5
\end{lstlisting}

\subsection{Data Types \& Type Conversion}
\paragraph{} Most of the time Python's strategy for handling different types of data is known as ``Duck Typing'', i.e. if it walks like a duck and sounds like a duck, then it probably is a duck so treat it as a duck. most of the time this works fine, and Python exceptions are fast and efficient so the general rule is to try to use a variable the way you want to use it, catch an exception, and do something different if necessary. Occasionally we need to treat data in particular ways, for example, \emph{coercing} a variable to act as a string. 

\begin{lstlisting}[style=DOS]
    >>> x=5
    >>> x
     5
    >>> str(x)
     '5'
    >>> int(x)
     5
    >>> float(x)
     5.0
    >>> bool(x)
     True
\end{lstlisting}
\paragraph{} Notice that although we started with our variable, x, being assigned a number value (an integer to be precise), we can wrap our variable in various functions to cause it to be treated as something other than an integer. Notice that each is subtly different, for example, the int is displayed as the number value and nothing more, but the string wraps the value in quotes.

\paragraph{} Let's look at a quick example of treating a variable of one types as though it is a different type. If we want to output the value of a variable with an explanatory message such as when we want to say ``the value of x is '' then add the actual value -- then we need to ensure that value so that it is treated as a string so it can added to the end of the message.

\begin{lstlisting}[style=DOS]
    >>> x=5
    >>> y="num is "
    >>> y+x
     Traceback (most recent call last):
       File "<stdin>", line 1, in <module>
     TypeError: cannot concatenate 'str' and 'int' objects
    >>> y+str(x)
     'num is 5'
\end{lstlisting}

\paragraph{} Notice that when we try to add the integer to our string we get an error, a traceback. However, when we do the same but explicitly say that our integer, x should be handled as a string, we get the desired behaviour.

\section{Help}
\label{help}
\paragraph{} We can get help using the builtin help function, e.g.

\begin{lstlisting}[style=DOS]
    >>> help()
\end{lstlisting}
\paragraph{} You can pass items into the help function such as variables and function names to get relevant information about them, e.g.

\begin{lstlisting}[style=DOS]
    >>> help(str)
\end{lstlisting}

\paragraph{} Should give you information about the string class.

\section{Strings}
\label{strings}

\paragraph{} Speaking of strings. If you want a string, then just wrap it in matching quotes, either single quotes, `, or double quotes, ``.

\begin{lstlisting}[style=DOS]
    >>> my_first_string = 'hello napier'
    >>> my_first_string
     'hello napier'
\end{lstlisting}

\subsection{String Operations}
\paragraph{} Once we have some strings we can do things with them. We can cause them to be handled multiple times, we concatenate them with other strings, and we can check what the strings contain:

\begin{lstlisting}[style=DOS]
    >>> my_first_string*2
     'hello napierhello napier'
    >>> my_first_string + " and goodbye"
     'hello napier and goodbye'
    >>> 'n' in my_first_string
     True
\end{lstlisting}

\paragraph{} We can also slice up our strings to work only with particular parts, for example, accessing only the characters at a give, zero-indexed, position, or the sub-string between two positions, or the \emph{head} of the string, from the beginning up to a given index, or the \emph{tail} of the string from a give index to the end:

\begin{lstlisting}[style=DOS]
    >>> my_first_string[3]
     'l'
    >>> my_first_string[0]
     'h'
    >>> my_first_string[4:7]
     'o n'
    >>> my_first_string[:9]
     'hello nap'
    >>> my_first_string[5:]
     ' napier'
\end{lstlisting}

\paragraph{} We can perform many more operations on strings, but this is a good start...

\subsection{String Methods}
\paragraph{} Python strings are objects, and objects generally have methods that you can use to manipulate them. For example, switching the case of the characters that make up the string, either making everything lowercase or uppercase, counting how many instances there are of a given element, replacing particular elements with alternatives, and stripping whitespace from the ends of the string (really useful when consuming strings from other places).

\begin{lstlisting}[style=DOS]
    >>> my_first_string.upper()
     'HELLO NAPIER'
    >>> my_first_string.lower()
     'hello napier'
    >>> my_first_string.count('n')
     1
    >>> my_first_string.count('e')
     2
    >>> my_first_string.replace('e', 'x')
     'hxllo napixr'
    >>> my_first_string.strip()
     'hello napier'
\end{lstlisting}


\section{Lists}
\paragraph{} Lists are an incredibly important aspect of Python programming\footnote{To be honest, as you continue exploring various prpogramming languages and methods for working with data, you'll probably discover that ``list processing'' is a fundamental method for working with data. Lots of data that we need to work with is presented as sequences of similar objects, events, or datapoints. So having tools to help us to process each element of any arbitrary list is a really powerful tool.}.

\subsection{List Elements}
\paragraph{} We use the square brackets, `$[$' and `$]$' to enclose a list and we can store anything in a list, even mixtures of different types of data.

\begin{lstlisting}[style=DOS]
    >>> []
     []
    >>> [1,2,3]
     [1, 2, 3]
    >>> my_first_list = [1,2,3]
    >>> my_first_list
     [1, 2, 3]
    >>> l1=[2, 2.3, 'string']
\end{lstlisting}

\paragraph{} We can construct lists in many ways, e.g. from variables, by directly including values, or from other lists:
\begin{lstlisting}[style=DOS]
    >>> a='this'
    >>> b='is'
    >>> my_list=[a,b,'my','list']
    >>> my_list
     ['this', 'is', 'my', 'list']
    >>> list_of_lists = [['a','list'],['another','list']]
    >>> list_of_lists
     [['a', 'list'], ['another', 'list']]
\end{lstlisting}

\paragraph{} We can then acccess elements of the list in various ways. Compare this to how we performed operations on strings earlier and consider how strings are really just lists of characters. In the following we access the members of the list using the zero-indexed position of the member. Notice that using the minus sign accesses the lists from the tail instead of the head. We can also slice the list using the `:' operator to access various sub-lists

\begin{lstlisting}[style=DOS]
    >>> my_list[1]
     'is'
    >>> my_list[-1]
     'list'
    >>> my_list[-2]
     'my'
    >>> my_list[-0]
     'this'
    >>> my_list[1:3]
     ['is', 'my']
    >>> my_list[1:]
     ['is', 'my', 'list']
    >>> my_list[:3]
     ['this', 'is', 'my']
\end{lstlisting}

\paragraph{} Return to our earlier ``list of lists'', we can also access these \emph{nested lists} using a similar notation:

\begin{lstlisting}[style=DOS]
    >>> list_of_lists
     [['a', 'list'], ['another', 'list']]
    >>> list_of_lists[0]
     ['a', 'list']
    >>> list_of_lists[1]
     ['another', 'list']
    >>> list_of_lists[1][0]
     'another'
\end{lstlisting}

\subsection{List Operations}

\paragraph{} We can perform operations on lists, for example, concatenating or joining them together using the `+' operator, multiplying lists using the `*' operator.

\begin{lstlisting}[style=DOS]
    >>> my_list
     ['this', 'is', 'my', 'list']
    >>> my_list + my_list
     ['this', 'is', 'my', 'list', 'this', 'is', 'my', 'list']
    >>> my_list * 2
     ['this', 'is', 'my', 'list', 'this', 'is', 'my', 'list']
\end{lstlisting}

\subsection{List Methods}

\paragraph{} We can also use the ethods associated with the list class to interact with a list, e.g. get the index of a list element, count 

\begin{lstlisting}[style=DOS]
    >>> my_list 
     ['this', 'is', 'my', 'list']
    >>> my_list.index('is')
     1
    >>> my_list.count('is')
     1
    >>> my_list.append("which")
    >>> my_list.append("is")
    >>> my_list.append("great")
    >>> my_list.count('is')
     2
    >>> my_list
     ['this', 'is', 'my', 'list', 'which', 'is', 'great']
    >>> my_list.sort()
    >>> my_list
     ['great', 'is', 'is', 'list', 'my', 'this', 'which']
    >>> my_list.remove('is')
    >>> my_list
     ['great', 'is', 'list', 'my', 'this', 'which']
    >>> my_list.pop()
     'which'
    >>> my_list.pop()
     'this'
    >>> my_list.pop(-1)
     'my'
\end{lstlisting}

\section{JSON}
\label{json}
\paragraph{} I don’t go into much detail in the workbook on this topic because it is a data manipulation thing rather than a webby thing, but perhaps an example might help (this was all done in the python command line REPL rather than a script but converting to a python script or using in your Flask app should be trivial):

\paragraph{} We can create a Python dictionary like this:
\begin{lstlisting}[style=DOS]
    >>> d = {'firstname':'simon', 'lastname':'wells'}
    >>> print d
    {'lastname': 'wells', 'firstname': 'simon’}
\end{lstlisting}

\paragraph{} We can import the JSON library and use it to create a JSON string representation of a Python dict as follows:
\begin{lstlisting}[style=DOS]
import json
    >>> s = json.dumps(d)
    >>> print s
    {"lastname": "wells", "firstname": "simon”}
\end{lstlisting}

\paragraph{} Notice that the dict and the string appear very similar in terms of output when they are printed? Internally they aren’t the same, one is just a string, but the other, the dict can be accessed by key, e.g.
\begin{lstlisting}[style=DOS]
    >>> print d['lastname']
    'wells'
\end{lstlisting}

\paragraph{} whereas doing the same with the string gets us an error, e.g.
\begin{lstlisting}[style=DOS]
    >>> print s[lastname]
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    NameError: name 'lastname' is not defined
\end{lstlisting}

\paragraph{} We can do the reverse, i.e. get a dict back from a JSON encoded string like follows:
\begin{lstlisting}[style=DOS]
    >>> d2 = json.loads(s)
\end{lstlisting}

\paragraph{} Now we can compare the original dict, d, with the new one, d2:
\begin{lstlisting}[style=DOS]
    >>> print d2
    >>> {u'lastname': u'wells', u'firstname': u'simon'}
    >>> print d
    {'lastname': 'wells', 'firstname': 'simon’}
\end{lstlisting}

\paragraph{} The main difference is the ‘u’ which indicates that the strings in the dict are explicitly unicode encoded. We can also access our elements of  the two dicts to compare them, e.g.
\begin{lstlisting}[style=DOS]
    >>> print d['lastname']
    'wells'
    >>> print d2['lastname']
    u’wells'
\end{lstlisting}

\paragraph{} So that is converting between Python dictionaries and JSON encoded strings. Now we want to serialise our string to a file then read them back in. To write our string s to the file “testfile.json” we can do this:
\begin{lstlisting}[style=DOS]
    >>> with open('testfile.json', 'w') as outfile:
    ...    outfile.write(s)
\end{lstlisting}

\paragraph{} Now open testfile.json in a text editor, like vim, or just use cat to show the contents and check it is the same as the dict/string that we had earlier. I made a small edit to testfile.json in the text editor to add a new key:value pair, e.g. ‘middlename':’none’ so that the information loaded back in differs from the original string written out. Now we just need to read the json file back into a dict within our program so that we can manipulate it, e.g.
\begin{lstlisting}[style=DOS]
    >>> with open('testfile.json') as infile:
    ...    new_dict = json.load(infile)
    ...    infile.close()
    ...    print new_dict
    ... 
    {u'middlename': None, u'lastname': u'wells', u'firstname': u'simon’}
\end{lstlisting}

\paragraph{} The only real challenge now is to design the right dictionary structure to capture the information you want to store, i.e. data about your collection….

\paragraph{} NB.   \url{https://jsonlint.com/} is really useful for testing that a bit of JSON is valid and \url{https://docs.python.org/2/library/json.html} documents the Python JSON library



\chapter{Git}
\label{git}

\paragraph{} This section will eventually contain a quickstart on Git to use as an aide memoire. However, in the meantime, we'll start with just enough to assist in the assignment hand-in.


\section{Bare Repositories}
\paragraph{} We need to create a Git repository that can be used as a remote repository, somewhere where you can store your own code, but from which others, like your markers, can retrieve your work. A bare repository is the Git terminology for such a remote Git repository. 

\paragraph{} There are actually two basic kinds of Git repository, \emph{working} repositories and \emph{bare} repositories. The kinds of repo that you have most likely worked with so far are working repositories. These are repositories in which you can add, edit, and delete files. Most files that you clone from other locations, like GitHub or BitBuckets are working repositories. Bare repositories are not designed for working in, they are missing the \emph{working tree}, the place where you would add, edit, and delete files. It is easy to convert between a bare and working repository so if you have one, then you can easily create the other type from it, i.e. cloning from a bare repository will create a working repository but cloning with the --bare argument from a working repo will give you a bare repo.

\paragraph{} So what is the purpose of the bare repository? Well, a bare repository is meant to serve as an authoritative focal point for collaborative development. This means a place from which other developers can clone, fetch, or push changes. The idea is to minimise the number of problems that can occur when working collaboratively, and the easiest way to do this is to ensure that copies of files associated with ``working'' repositories are not stored in the exact same place as the repository around which collaborative development is focussed.

This basically means that, for submission of our assignment, to make it available to other users of your VM such as your markers, we need to create a repo that can be shared between multiple people (assuming they have access to the machine that the repo is stored on, otherwise some additional steps might be required\footnote{but this is not the case for our VMs, your markers are already able to access your VM}). Note that you don't do work directly in a bare repo, you must clone it to a working location then push any changes that you've committed back to the bare repo.

\paragraph{} Create a folder in your home directory and name it something useful like test-bare-repo, then change directory into your newly created location e.g.:

\begin{lstlisting}[style=DOS]
    $ mkdir test-bare-repo
    $ cd test-bare-repo
\end{lstlisting}

\paragraph{} At the moment this is just a regular folder on the filesystem but Git can add files to turn it into a Git repository. To turn this into a git repository we need to do the following: 

\begin{lstlisting}[style=DOS]
    $ git init --bare .
\end{lstlisting}

\paragraph{} In order to use this repository you will need to clone it to a working location on your VM (or on another machine if you are developing in another place and only deploying to your VM.

\begin{framed}
\textbf{Note} If you \emph{already} have a Git repository set up that you want to use then you can make a bare clone of that repository using a variation on the above command, e.g.

\begin{lstlisting}[style=DOS]
    $ git clone --bare some-repo-name bare-repo-name
\end{lstlisting}

\paragraph{} which should give you a message like:

\begin{lstlisting}[style=DOS]
    Cloning into bare repository 'working-repo.git'...
    done.
\end{lstlisting}
\end{framed}

\paragraph{} As we noted earlier, we can't work directly on a bare repository, we have to clone it to a different location to work on it's contents. Once we've made changes to our working repo, then we can push the changes back to our bare repo. The following sections are a small indicative demonstration of using our bare repo. You might have to adjust paths and filenames to match your actual setup.

\paragraph{} Starting in the bare repo folder run git log, e.g

\begin{lstlisting}[style=DOS]
    $ git log
\end{lstlisting}

\paragraph{} You should get output similar to the following:

\begin{lstlisting}[style=DOS]
    fatal: your current branch 'master' does not have any commits yet
\end{lstlisting}

\paragraph{} This is just letting us know that our bare repo is empty and hasn't yet got any commits. Note that you can't make changes directly to a bare repo. Instead you should clone it to another location, a working location, then push any changes to your working copy back to the bare repo. Let's do that.

\paragraph{} First we need to make a working copy of our bare repo. Change directory to another location in your account then clone your bare repo to create a working repo:

\begin{lstlisting}[style=DOS]
    $ git clone test-bare-repo working-repo
\end{lstlisting}

\paragraph{} This will clone our initial bare repo into a working repo called ``working-repo''.

\paragraph{} You can now move into your working repo and treat it like a regular Git repo, e.g. adding files, commiting them, and then pushing them back to the bare repo. Let's see an example of that. First move into our couserwork working repo and create a new file:

\begin{lstlisting}[style=DOS]
    $ cd working-repo
    $ touch hello.txt
\end{lstlisting}

\paragraph{} Now edit the file, then add it your repo:

\begin{lstlisting}[style=DOS]
    $ git add hello.txt
    $ git commit -m "Our first file"
\end{lstlisting}

\paragraph{} If you run git log now you should see a message like this:

\begin{lstlisting}[style=DOS]

    commit fffd9f14062f39a4abc7360d0b342e7979319277 (HEAD -> master, origin/master)
    Author: Simon Wells <siwells@gmail.com>
    Date:   Thu Nov 5 07:33:18 2019 +0000

        Add first file
\end{lstlisting}

\paragraph{} Now we have made changes to our working repo but we want to push those changes back to our bare repo so that those changes are available to other members of the team. We can do that like this:

\begin{lstlisting}[style=DOS]
    $ git push
\end{lstlisting}

\paragraph{} Which should yield a message similar to this (your paths, file, and repo names will likey differ):

\begin{lstlisting}[style=DOS]
    Counting objects: 3, done.
    Writing objects: 100% (3/3), 226 bytes | 226.00 KiB/s, done.
    Total 3 (delta 0), reused 0 (delta 0)
    To /Users/simon/Desktop/_tmp/test-bare-repo
     * [new branch]      master -> master
\end{lstlisting}

\paragraph{} You can now change directory to your bare repository and run git log again to verify that your updates to the repo are reflected accurately in the bare repository.

\paragraph{} Anyone who has read access to the folder on your VM that contains your bare repo can clone it. This includes the markers for this module. You should now create a bare repo in the location specified in the assignment descriptor, e.g. at the following complete pathname:

\begin{lstlisting}[style=DOS]
    /home/<matriculation-number>/submission/project.git
\end{lstlisting}

\paragraph{} NB. Recall that your home directory is /home/$<$matriculation-number$>$ so you just need a new sub-directory called submission then a sub-directory of that called project.git which is then initialised as a bare Git repo.

\paragraph{} You should also verify that the bare repo can be cloned to another machine using the command specified in the assignment descriptor, e.g.

\begin{lstlisting}[style=DOS]
    $ git clone matriculation-number@webtech-NUMBER.napier.ac.uk:~/submission/project.git
\end{lstlisting}

\paragraph{} NB. You will need to add in your own matriculation number and VM number to complete this command correctly. Try cloning your repository from another machine to verify that it works. You can use a tool like git-bash if your are on a lab machine. It's a good idea to do this way in advance of the hand-in. If you have trouble, aske a lab demonstrator for assistance.

\paragraph{} Two things to note. Firstly, you can set up multiple remote repositories, each of which can act as a backup of your repo and the files that it contains. You can even add GitHub or BitBucket repositories as remotes which can be useful. Secondly, This approach, using a Git remote, is nothin special, it's a standard way to set up a Git repo so that it can be shared between multiple developers, so if you need to do a team project, but you don't want to risk the security or privacy of your code by hosting on a cloud service, then this is one way to solve the problem.


\chapter{Deployment}
\label{deployment}

The final step in our advanced web technologies journey is to deploy the apps that we've been building all trimester. Whilst the way that we've currently been deploying our apps is perfectly fine for development and debugging, there are a few problems:

\begin{enumerate}
\item Our app isn't available on port 80 - so it is not located in the place that our browser would look at by default. Our users must know to choose a different port and must specifically indicate that in the browser.
\item Our app stops running when we log out. At the moment we run our app from the command line as a user-level program. What we really want is for an item of server software to manage our app after we log out, and to restart our app if it ever dies.
\end{enumerate}

\paragraph{} We can solve both of these problems by using a piece of web server software to host our app, and making sure that that server software make our app available at an appropriate address.

\paragraph{} We will use $\mu$WSGI (pronounced micro-whisky) for deployment of our Flask apps. Recall that what makes our Flask apps into web-apps, rather than just Python scripts, is the fact that Flask implements a particular interface, called WGSI, which server software can communicate through to present your app's functionality to users of the Web. There are many server applications available that can serve WSGI apps like our Flask apps, $\mu$WSGI happens to be one of these, and a particularly good one at that.

\paragraph{} First we need to install $\mu$WSGI. This is just a Python package so we can use pip to install it. To keep things simple we'll install it as a system wide Python package rather than using a virtualenv.

\begin{lstlisting}[style=DOS]
    $ pip install uwsgi
\end{lstlisting}


\paragraph{} Now gather some information to supply to $\mu$WSGI. You will need the following:

\begin{enumerate}
\item The full path to the main python script for your Flask app.
\item The full path to the folder in which your main python script for your flask app is located.
\item The full path to the folder in which your virtualenv is located (this is the folder containing the bin/ include/ and lib/ folders.
\end{enumerate}

\paragraph{} It is important to note that you shouldn't just type in the commands that follow \emph{as is} because the specific locations and names of your files are important. So you might have to adjust things to match the location of your own files and the names that you've given them\footnote{similar for your matriculation number}. Note that you will also be interacting with the operating system and performing some sysadmin tasks using the sudo command, so you should be careful and take your time to get things right.

\paragraph{} Now, we will need to perform several steps to get $\mu$WSGI to server our app correctly. The first step is just a verification step. Let's supply the information that we just collected to $\mu$WSGI at the command line and check that it works (we can them create configuration files from this information once we know that it works.

\paragraph{} For example, assuming that our flask app is located in this folder: 
\begin{lstlisting}
/home/40008609/testapp/ 
\end{lstlisting}
in a file called \emph{hello\_flask.py}  that our virtualenv is stored in the same folder and that we want our flask app to think that it is running in the same location (for access to relative folders like static, log locations, and configuration files), then we should be able to run $\mu$WSGI with the following configuration:

\begin{lstlisting}[style=DOS]
    $ uwsgi --http :5000 --wsgi-file /home/40008609/testapp/hello_flask.py --callable app --virtualenv /home/40008609/testapp/ --pythonpath /home/40008609/testapp/
\end{lstlisting}

\paragraph{} Note that the folder locations for your own app might vary (and your matirculation number will definitely be different). Also note that you \emph{must} stop your existing Flask debug server if it is already running as otherwise you will be trying to run two instances of your app on the same port which won't work correctly. When you are ready, try it out. If it works then you should be able to access your site at the normal port 5000 location as you have been doing all trimester. The only difference is that our app is made available by a piece of robust server sotware that is optimsed for deployment rather than for development.

\paragraph{} To stop our $\mu$WSGI server we can use $<$CTRL$>$ - C\footnote{If you get a message that something is already running on the 5000 port then check whether you still have your flask debug instance running, and if so, stop it. If things still won't run then us the ps command and search within the results for instances of $\mu$wsgi e.g. \$ ps aux $|$ grep [u]wsgi then kill the offending process using the kill command, e.g. \$ kill 51474}.

\paragraph{} If this has worked, we can move on to the next steps of:

\begin{enumerate}
\item Creating an ini file for our flask app using the parameters that we just tested above.
\item Creating a config file for $\mu$WSGI so that the operating system can start everything up automatically.
\end{enumerate}

\paragraph{} Let's do the first part. We need to create an ini file that will tell $\mu$WSGI where to find our Flask app. We'll use our parameters from above (as we know that they work, if things didn't work before, then they won't magically fix themselves now so it's worth returning to make sure that you can initialise $\mu$WSGI in the terminal and get your flask app running manually before continuing. Create a new folder in your flask app and call it vassals then create a file called deploy.ini in your new vassals folder. It doesn't really matter where we put this file because we will pass it's location to $\mu$WSGI for subsequent use but it helps to stay organised\footnote{but obviously you don't want to change it's location later without also telling $\mu$WSGI where to find it}. Now edit that ini file to contain the following:

\begin{lstlisting}
[uwsgi]
	wsgi-file = 	/home/40008609/testapp/hello_flask.py
	virtualenv = 	/home/40008609/testapp/
	pythonpath = 	/home/40008609/testapp/
	chdir = 	    /home/40008609/testapp/
  	callable = app
	http = :80
	worker = 8
	master = true
	processes = 8
	die-on-term = true
	harakiri = 40
	heartbeat = 10
\end{lstlisting}

\paragraph{} Note that the only lines that we might need to edit in this are lines 2, 3, 4, \& 5 to reflect the actual location of our flask app as I've used dummy folders in the example.

\paragraph{} Now we need to create a configuration file that the operating system can use to start $\mu$WSGI and tell the new instance of $\mu$WSGI where to find your flask app (using the ini file we created in the previous step). In your home folder create the following file and name it $\mu$wsgi.service

\begin{lstlisting}
[unit]
Description=uWSGI Service
After=syslog.target

[Service]
ExecStart=/home/40008609/.local/bin/uwsgi --emperor /home/40008609/demo/vassals/deploy.ini
RuntimDirectory=uwsgi
Restart=always
KillSignal=SIGQUIT
Type=notify
StandardError=syslog
NotifyAccess=all

[Install]
WantedBy=multi-user.target
\end{lstlisting}

\paragraph{} Note that you will have to alter line 6 to reflect your own matriculation numer and the path to your deploy.ini file

\paragraph{} Our final step is to move the $\mu$wsgi.service file into the following location

\begin{lstlisting}
    /etc/systemd/system
\end{lstlisting}

\paragraph{} This is because the operating system uses software called systemd to control starting and stopping services, like our WSGI server, automatically. We use the following command to do this:

\begin{lstlisting}[style=DOS]
    $ sudo cp uswgi.service /etc/systemd/system
\end{lstlisting}

\paragraph{} We now need to make our new service exectuable then tell systemd to reload itself to make our $\mu$wsgi.service available:

\begin{lstlisting}[style=DOS]
    $ sudo chmod +x uwsgi.service
    $ sudo systemctl daemon-reload
\end{lstlisting}

All going well, we can now start the server and hence our flask app, and

\begin{lstlisting}[style=DOS]
    $ sudo systemctl start uwsgi
\end{lstlisting}

\paragraph{} and can use
\begin{lstlisting}[style=DOS]
    $ sudo systemctl stop uwsgi
\end{lstlisting}

to stop it. Note that this process might take a wee while to complete so wait for your prompt to return indicating that the command has finished before you panic. The server will now also automatically start and stop things if the server is rebooted as well as enabling you to manually start and stop the service.

\paragraph{} Your site should now be available at \url{http://webtech-NUMBER.napier.ac.uk}

\paragraph{} To summarise, to get your Flask app running on port 80 and hosted by $\mu$WSGI then you need to do the following (making sure to adapt this to your specific web-app):

\begin{enumerate}
\item Install $\mu$WSGI
\item Create an ini file for our flask app that $\mu$WSGI will use
\item Create a systemd service file for $\mu$WSGI and move it to /etc/systemd/system
\item Tell systemd that our new service exists
\item Start our new service
\end{enumerate}

\paragraph{} Note that this is for deployment, i.e. to have your web app up and running permanently, and isn't meant to be used for development. So if you are still developing your app, then you should continue to use the Flask debug server until all features are implemented.



\backmatter

\bibliographystyle{plain}

\bibliography{adv-web-tech}

\end{document}

